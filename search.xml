<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Mybatis学习笔记🕊</title>
      <link href="/2018/04/20/mybatis/"/>
      <url>/2018/04/20/mybatis/</url>
      
        <content type="html"><![CDATA[<p><em>说明：本文由大量的源代码，及截图，建议读者，操作一遍。ide：IDEA。文末有笔记及视频分享</em></p><p>数据表的sql下载<a href="https://pan.baidu.com/s/16WabwxxmnPghSRw5DpCEfQ" target="_blank" rel="noopener"> 密码: xjjw</a></p><h2 id="1、对原生态jdbc程序（单独使用jdbc开发）问题总结"><a href="#1、对原生态jdbc程序（单独使用jdbc开发）问题总结" class="headerlink" title="1、对原生态jdbc程序（单独使用jdbc开发）问题总结"></a>1、对原生态jdbc程序（单独使用jdbc开发）问题总结</h2><p>先来看一部分代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Public static void main(String[] args) &#123;</span><br><span class="line">Connection connection = null;</span><br><span class="line">PreparedStatement preparedStatement = null;</span><br><span class="line">ResultSet resultSet = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">//通过驱动管理类获取数据库链接</span><br><span class="line">connection =  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;mysql&quot;);</span><br><span class="line">//定义sql语句 ?表示占位符</span><br><span class="line">String sql = &quot;select * from user where username = ?&quot;;</span><br><span class="line">//获取预处理statement</span><br><span class="line">preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">//设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值</span><br><span class="line">preparedStatement.setString(1, &quot;王五&quot;);</span><br><span class="line">//向数据库发出sql执行查询，查询出结果集</span><br><span class="line">resultSet =  preparedStatement.executeQuery();</span><br><span class="line">//遍历查询结果集</span><br><span class="line">while(resultSet.next())&#123;</span><br><span class="line">System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">//释放资源</span><br><span class="line">if(resultSet!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">resultSet.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(preparedStatement!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">preparedStatement.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(connection!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">connection.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码有如下几个问题：</p><ul><li>数据库连接，使用时创建，不使用就关闭，对数据库进行频繁连接开启和关闭，造成数据库资源的浪费<ul><li>解决：<strong>使用数据库连接池管理数据库连接</strong></li></ul></li><li>将sql 语句硬编码到Java代码中，如果sql语句修改，需要对java代码重新编译，不利于系统维护<ul><li>解决：<strong>将sql语句设置在xml配置文件中，即使sql变化，也无需重新编译</strong></li></ul></li><li>向preparedStatement中设置参数，对占位符位置和设置参数值，硬编码到Java文件中，不利于系统维护<ul><li>解决：<strong>将sql语句及占位符，参数全部配置在xml文件中</strong></li></ul></li><li>从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。<ul><li>解决：<strong>将查询的结果集，自动映射成java对象</strong></li></ul></li></ul><h2 id="2、Mybatis框架原理-掌握"><a href="#2、Mybatis框架原理-掌握" class="headerlink" title="2、Mybatis框架原理(掌握)"></a>2、Mybatis框架原理(掌握)</h2><ul><li><strong>什么是Mybatis？</strong><ul><li>mybatis是一个持久层的框架，是apache下的顶级项目。</li><li>mybatis托管到goolecode下，后来托管到github下:<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">mybatis Github地址</a></li><li>mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</li><li>mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射）</li></ul></li><li><strong>Mybatis原理图</strong>：<br><img src="https://img-blog.csdn.net/20180420191152719?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul><h2 id="3、Mybatis入门程序"><a href="#3、Mybatis入门程序" class="headerlink" title="3、Mybatis入门程序"></a>3、Mybatis入门程序</h2><ul><li>Mybatis和SpringMVC实现订单商品案例</li><li><strong>需求</strong><ul><li>根据用户的id查询用户信息</li><li>根据用户的名称模糊查询用户信息</li><li>添加用户</li><li>删除用户</li><li>更新用户</li></ul></li><li><p>Mybatis的运行环境（jar包）</p><ul><li><p>从这里点击<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">下载</a></p><p>笔者下载的是：<br><img src="https://img-blog.csdn.net/20180420192318329?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>下载<strong>mybatis-3.4.6.zip</strong>解压即可<br><img src="https://img-blog.csdn.net/20180420192421830?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li>lib下：依赖包</li><li>mybatis-3.4.6.jar：核心 包</li><li>mybatis-3.4.6.pdf，操作指南</li></ul></li></ul><p><strong>目录结构：</strong><br><img src="https://img-blog.csdn.net/20180421194813729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>jar包结构</strong><br><img src="https://img-blog.csdn.net/20180421194952190?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>过程中需要数据库的连接，junit的调试，注意要将jar包<strong>build path！</strong></p></li></ul><p><strong>log4j.properties</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line"># 开发环境下，日志级别要设置成DEBUG或者ERROR</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure></p><p><strong>SqlMapConfig.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理--&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池--&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--加载映射文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p><strong>User.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    命名空间，作用为，对sql进行分类化管理，理解sql隔离，</span><br><span class="line">    注意：使用mapper代理方法开发，namespace有特殊作用</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line">    &lt;!--在映射文件中配置sql--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        findUserById</span><br><span class="line">        通过select执行数据库查询</span><br><span class="line">        id：标识映射文件的sql</span><br><span class="line">        将sql语句封装到mappedStatement对象中，所以将id称为Statement的id</span><br><span class="line">        #&#123;&#125;:表示一个占位符</span><br><span class="line">        parameterType:指定输入参数的类型</span><br><span class="line">        #&#123;id&#125;：其中的id表示接收输入的参数，参数的名称就是id，如果输入参数类型为简单类型，那么#&#123;&#125;中的参数可以任意，可以是value或其他</span><br><span class="line">        resultType：指定sql输出结果的所映射的Java对象类型，select指定的resultType表示将单条记录映射成的Java对象</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">        select * from user where id=#&#123;VALUE &#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        findUserByName</span><br><span class="line">        $&#123;&#125;:表示拼接字符串，将接收到的sql不加任何修饰拼接在sql语句里</span><br><span class="line">        使用$&#123;&#125;拼接sql，可能会引起sql注入,一般不建议使用</span><br><span class="line">        $&#123;value&#125;：接收参数的内容，如果传入的的是简单类型，$&#123;&#125;中只能使用value</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">        select * from user WHERE username LIKE &apos;%$&#123;value&#125;%&apos;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        添加用户</span><br><span class="line">        parameterType:指定参数类型为pojo类型</span><br><span class="line">        #&#123;&#125;中指定pojo的属性名，接收到的pojo对象的属性值，mybatis通过OGNL获取对象的值</span><br><span class="line">        SELECT LAST_INSERT_ID():得到刚刚insert进去的记录的主键值，只适用于主键自增</span><br><span class="line">        非主键自的则需要使用uuid()来实现,表的id类型也得设置为tring(详见下面的注释)</span><br><span class="line">        keyProperty：将查询到的主键值设置到SparameterType指定的对象的哪个属性</span><br><span class="line">        order:SELECT LAST_INSERT_ID()执行顺序，相当于insert语句来说它的实现顺序</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">        &lt;!--uuid()--&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.String&quot;&gt;</span><br><span class="line">              SELECT uuid()</span><br><span class="line">            &lt;/selectKey&gt;</span><br><span class="line">            insert into user (id,username,birthday,sex,address) value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">        --&gt;</span><br><span class="line">      &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">          SELECT LAST_INSERT_ID()</span><br><span class="line">      &lt;/selectKey&gt;</span><br><span class="line">      insert into user (username,birthday,sex,address) value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">        UPDATE user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><p><strong>User.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.po;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    //用户po</span><br><span class="line">    //属性名和数据库字段名对应</span><br><span class="line">    private int id;</span><br><span class="line">    private String username;// 用户姓名</span><br><span class="line">    private String sex;// 性别</span><br><span class="line">    private Date birthday;// 生日</span><br><span class="line">    private String address;// 地址</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MybatisFirst.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.first;</span><br><span class="line"></span><br><span class="line">import com.nuc.mybatis.po.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MybatisFirst &#123;</span><br><span class="line">    //根据id查询用户信息，得到一条记录</span><br><span class="line">    @Test</span><br><span class="line">    public void findUserByIdTest() throws IOException &#123;</span><br><span class="line">        //mybatis配置文件</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        //通过工厂得到SqlSession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        //通过SqlSession操作数据库</span><br><span class="line">        //第一个参数：映射文件中的statement的id，等于namespace+&quot;.&quot;+statement的id</span><br><span class="line">        //第二个参数：指定和映射文件中所匹配的所有parameterType的类型</span><br><span class="line">        //sqlSession.selectOne()的结果是映射文件中所匹配的resultType类型的对象</span><br><span class="line">        User user = sqlSession.selectOne(&quot;test.findUserById&quot;,1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        //释放资源</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">    //根据用户名称查询用户列表</span><br><span class="line">    @Test</span><br><span class="line">    public void findUserByName() throws IOException &#123;</span><br><span class="line">        //mybatis配置文件</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        //通过工厂得到SqlSession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        List&lt;User&gt; list= sqlSession.selectList(&quot;test.findUserByName&quot;,&quot;小明&quot;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">    小结：</span><br><span class="line">    selectOne和selectList：</span><br><span class="line"></span><br><span class="line">    selectOne表示查询出一条记录进行映射。如果使用selectOne可以实现使用selectList也可以实现（list中只有一个对象）。</span><br><span class="line">    selectList表示查询出一个列表（多条记录）进行映射。如果使用selectList查询多条记录，不能使用selectOne。</span><br><span class="line">    如果使用selectOne报错：</span><br><span class="line">    org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 4</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">    @Test</span><br><span class="line">    public void insertUserTest() throws IOException &#123;</span><br><span class="line">        //mybatis配置文件</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        //通过工厂得到SqlSession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;宋江涛&quot;);</span><br><span class="line">        user.setBirthday(new Date());</span><br><span class="line">        user.setSex(&quot;男&quot;);</span><br><span class="line">        user.setAddress(&quot;山西&quot;);</span><br><span class="line">        //list中的user和映射文件User.xml中的resultType的类型一直</span><br><span class="line">        sqlSession.insert(&quot;test.insertUser&quot;,user);</span><br><span class="line">        //提交事务</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        //获取主键</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">    //删除用户</span><br><span class="line">    @Test</span><br><span class="line">    public void deleteUserTest() throws IOException &#123;</span><br><span class="line">        //mybatis配置文件</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        //通过工厂得到SqlSession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        //list中的user和映射文件User.xml中的resultType的类型一直</span><br><span class="line">        sqlSession.delete(&quot;test.deleteUser&quot;,30);</span><br><span class="line">        //提交事务</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //更新用户</span><br><span class="line">    @Test</span><br><span class="line">    public void updateUserTest() throws IOException &#123;</span><br><span class="line">        //mybatis配置文件</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        //通过工厂得到SqlSession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setId(27);</span><br><span class="line">        user.setUsername(&quot;宋江涛new2&quot;);</span><br><span class="line">        user.setBirthday(new Date());</span><br><span class="line">        user.setSex(&quot;男&quot;);</span><br><span class="line">        user.setAddress(&quot;山西太原new&quot;);</span><br><span class="line">        //list中的user和映射文件User.xml中的resultType的类型一直</span><br><span class="line">        sqlSession.update(&quot;test.updateUser&quot;,user);</span><br><span class="line">        //提交事务</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>数据库的设计图</strong><br><img src="https://img-blog.csdn.net/2018042120040421?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180421200413843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>部分测试结果</strong><br><img src="https://img-blog.csdn.net/20180421203823427?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>jdbc的测试程序，前面已经沾过。</strong><br><strong>重点内容在代码的注释中均已说明</strong></p><p><strong>mybatis和hibernate本质区别和应用场景</strong></p><ul><li><p>hibernate：是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。<br>对sql语句进行优化、修改比较困难的。</p><ul><li>应用场景：<ul><li>适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa。。</li></ul></li></ul></li><li><p>mybatis：专注是sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全 的ORM框架，虽然程序员自己写sql，mybatis 也可以实现映射（输入映射、输出映射）。</p><ul><li>应用场景：<ul><li>适用与需求变化较多的项目，比如：互联网项目。</li></ul></li></ul></li></ul><p><strong>企业进行技术选型，以低成本 高回报作为技术选型的原则，根据项目组的技术力量进行选择。</strong></p><h2 id="4、Mybatis开发dao的方法"><a href="#4、Mybatis开发dao的方法" class="headerlink" title="4、Mybatis开发dao的方法"></a>4、Mybatis开发dao的方法</h2><ul><li><p><strong>原始dao开发方法（程序需要编写dao接口和dao实现类）(掌握)</strong></p><ul><li>在原有项目的基础上，<strong>src目录下创建com.nuc.mybatis.dao</strong></li><li>在这个包里有两个文件，一个是<strong>UserDao.java</strong>，另一个是<strong>UserDaoImpl.java</strong>这个类继承接口<strong>UserDao.java</strong></li><li>在创建一个和src同级的文件夹（记的把它标记为sources）具体方法见<a href="https://blog.csdn.net/song_jiangtao/article/details/80030243" target="_blank" rel="noopener">详情</a></li><li><p>在test下创建<strong>com.nuc.mybatis.test</strong>，创建类<strong>UserDaoImplTest.java</strong></p><p><strong>具体目录结构：</strong><br><img src="https://img-blog.csdn.net/20180422184535281?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>结构中的相关mapper请先忽略</strong></p></li></ul></li></ul><p><strong>UserDao.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.dao;</span><br><span class="line"></span><br><span class="line">import com.nuc.mybatis.po.User;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    //dao原始开发</span><br><span class="line">    //根据id查询用户信息</span><br><span class="line">    public User findUserById(int id) throws Exception;</span><br><span class="line">    //添加用户</span><br><span class="line">    public void insertUser(User user) throws Exception;</span><br><span class="line">    //删除用户</span><br><span class="line">    public void deleteUser(int id) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>UserDaoImpl.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.dao;</span><br><span class="line"></span><br><span class="line">import com.nuc.mybatis.po.User;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    //原生态的dao</span><br><span class="line">    //需要向dao实现类里注入SqlSessionFactory</span><br><span class="line">    //通过构造方法</span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    public UserDaoImpl(SqlSessionFactory sqlSessionFactory)&#123;</span><br><span class="line">        this.sqlSessionFactory=sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public User findUserById(int id) throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = sqlSession.selectOne(&quot;test.findUserById&quot;,id);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void insertUser(User user) throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        sqlSession.insert(&quot;test.insertUser&quot;,user);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void deleteUser(int id) throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        sqlSession.insert(&quot;test.deleteUser&quot;,id);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>UserDaoImplTest.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.test;</span><br><span class="line"></span><br><span class="line">import com.nuc.mybatis.mapper.UserMapper;</span><br><span class="line">import com.nuc.mybatis.po.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class UserMapperTest &#123;</span><br><span class="line">    //原始dao的测试</span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception&#123;</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂</span><br><span class="line">        sqlSessionFactory = new</span><br><span class="line">                SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testFindUserById() throws Exception&#123;</span><br><span class="line">      SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       //创建UserMapper的对象,mybatis自动调用</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User user = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testFindUserByName() throws Exception&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        //创建UserMapper的对象,mybatis自动调用</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; list= userMapper.findUserByName(&quot;宋江涛&quot;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    //其他的测试，可以照猫画虎</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>测试结果：</strong><br><img src="https://img-blog.csdn.net/20180422185457670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li><p><strong>Mybatis的mapper接口（相当于dao接口）代理开发方法(掌握)</strong></p><p>  <strong>根据上面的结构图创建相应文件，源码如下：</strong></p></li></ul><p><strong>UserMapper.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.mapper;</span><br><span class="line"></span><br><span class="line">import com.nuc.mybatis.po.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    //mapper代理开发和dao开发对比</span><br><span class="line">//    mapper接口,相当于dao接口，mybatis可以自动生成mapper接口实现类的代理对象</span><br><span class="line">    //根据id查询用户信息</span><br><span class="line">    public User findUserById(int id) throws Exception;</span><br><span class="line">    //根据用户名查询用户列表</span><br><span class="line">    public List&lt;User&gt;findUserByName(String name) throws Exception;</span><br><span class="line">    //添加用户</span><br><span class="line">    public void insertUser(User user) throws Exception;</span><br><span class="line">    //删除用户</span><br><span class="line">    public void deleteUser(int id) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>UserMapper.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.nuc.mybatis.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">        select * from user where id=#&#123;VALUE &#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">        select * from user WHERE username LIKE &apos;%$&#123;value&#125;%&apos;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">     </span><br><span class="line">      &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">          SELECT LAST_INSERT_ID()</span><br><span class="line">      &lt;/selectKey&gt;</span><br><span class="line">      insert into user (username,birthday,sex,address) value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.nuc.mybatis.po.User&quot;&gt;</span><br><span class="line">        UPDATE user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><p><strong>在测试之前需要在SqlMapConfig.xml中加载mapper.xml这个映射文件</strong><br><img src="https://img-blog.csdn.net/20180422191151327?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>UserMapperTest.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.test;</span><br><span class="line"></span><br><span class="line">import com.nuc.mybatis.mapper.UserMapper;</span><br><span class="line">import com.nuc.mybatis.po.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class UserMapperTest &#123;</span><br><span class="line">    //原始mapper的测试</span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception&#123;</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂</span><br><span class="line">        sqlSessionFactory = new</span><br><span class="line">                SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testFindUserById() throws Exception&#123;</span><br><span class="line">      SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       //创建UserMapper的对象,mybatis自动调用</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User user = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testFindUserByName() throws Exception&#123;</span><br><span class="line">    //返回列表测试</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        //创建UserMapper的对象,mybatis自动调用</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; list= userMapper.findUserByName(&quot;宋江涛&quot;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>部分测试结果：</strong><br><img src="https://img-blog.csdn.net/20180422185514111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>总结：</strong></p><ul><li><strong>原始dao开发问题</strong><ul><li>dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。</li><li>调用sqlsession方法时将statement的id硬编码了</li></ul></li><li><p><strong>mapper开发</strong></p><ul><li>只需要编写两个文件，mapper.java,mapper.xml。即可，不需要类来继承它。</li><li><p>mapper开发只需要遵守几个规范即可</p><ul><li><strong>在mapper.xml中namespace等于mapper接口地址</strong><br><img src="https://img-blog.csdn.net/20180422190340650?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><strong>mapper.java接口中的方法名和mapper.xml中statement的id一致</strong><br><img src="https://img-blog.csdn.net/20180422190515638?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180422190525912?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><strong>mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致。</strong><br><img src="https://img-blog.csdn.net/20180422190700191?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180422190712411?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><strong>mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。</strong><br><img src="https://img-blog.csdn.net/20180422190756669?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180422190807604?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li><p>其实，以上开发规范主要是对下边的代码<strong>进行统一生成：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id);</span><br><span class="line">sqlSession.insert(&quot;test.insertUser&quot;, user);</span><br><span class="line">。。。。</span><br></pre></td></tr></table></figure></li><li><p><strong>mapper接口方法参数只能有一个是否影响系统 开发？mapper接口方法参数只能有一个，系统是否不利于扩展维护？</strong></p><ul><li>系统 框架中，dao层的代码是被业务层公用的。</li><li>即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。</li></ul><p><strong>注意：持久层方法的参数可以包装类型、map。。。，service方法中建议不要使用包装类型（不利于业务层的可扩展）。</strong></p></li></ul></li></ul><h2 id="5、Mybatis配置文件SqlMapConfig-xml"><a href="#5、Mybatis配置文件SqlMapConfig-xml" class="headerlink" title="5、Mybatis配置文件SqlMapConfig.xml"></a>5、Mybatis配置文件SqlMapConfig.xml</h2><ul><li><p>properties（属性）</p><ul><li>将数据库连接的参数单独配置在，db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。</li><li><strong>好处：</strong>方便对参数进行统一管理，其它xml可以引用该db.properties</li><li><p><strong>特性：</strong> MyBatis 将按照下面的顺序来加载属性：</p><ul><li>在 properties 元素体内定义的属性首先被读取。 </li><li>然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 </li><li><p>最后读取parameterType传递的属性，它会覆盖已读取的同名属性。</p><p><strong>建议：</strong></p><ul><li>不要在properties元素体内添加任何属性值，只将属性值定义在properties文件中。</li><li>在properties文件中定义属性名要有一定的特殊性，如XXXXX.XXXXX.XXXX<br><img src="https://img-blog.csdn.net/20180422202525550?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180422202534357?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul></li></ul></li><li>settings（全局配置参数）<ul><li>mybatis框架在运行时可以调整一些运行参数。比如：开启二级缓存、开启延迟加载。。<strong>全局参数将会影响mybatis的运行行为。具体如下：</strong><br><img src="https://img-blog.csdn.net/20180422203142431?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180422203155118?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180422203206632?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>typeAliases（类型别名）(<strong>重点</strong>)<ul><li>单个定义<br><img src="https://img-blog.csdn.net/20180422205018480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>批量定义（常用）<br><img src="https://img-blog.csdn.net/20180422205107494?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>这样在其他地方就可以使用，例如：<br><img src="https://img-blog.csdn.net/20180422205352753?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>mybatis默认支持的别名<br><img src="https://img-blog.csdn.net/20180422205223880?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>typeHandlers（类型处理器）<ul><li>mybatis中通过typeHandlers完成jdbc类型和java类型的转换。通常情况下，mybatis提供的类型处理器满足日常需要，不需要自定义.</li><li>mybatis支持的类型处理器<br><img src="https://img-blog.csdn.net/2018042419301948?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/2018042419302869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>objectFactory（对象工厂）<ul><li>这个自行查看下载mybatis时附带的pdf文件，用的不多</li></ul></li><li>plugins（插件）</li><li>environments（环境集合属性对象）<ul><li>environment（环境子属性对象）<ul><li>transactionManager（事务管理）</li><li>dataSource（数据源）</li></ul></li></ul></li><li>mappers（映射器）<ul><li>通过resource<br><img src="https://img-blog.csdn.net/20180424194937777?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>通过class<br><img src="https://img-blog.csdn.net/20180424194956372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>通过package(推荐使用)<br><img src="https://img-blog.csdn.net/20180424195023388?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul><h2 id="6、Mybatis核心"><a href="#6、Mybatis核心" class="headerlink" title="6、Mybatis核心"></a>6、Mybatis核心</h2><ul><li><p><strong>Mybatis输入映射（掌握）</strong></p><ul><li>通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型<ul><li>传递pojo的包装对象<ul><li><strong>需求：</strong>完成用户信息的综合查询，需要传入查询条件很复杂（可能包括用户信息、其它信息，比如商品、订单的）</li><li>针对上边需求，建议使用自定义的包装类型的pojo。<br>在包装类型的pojo中将复杂的查询条件包装进去。</li></ul></li></ul></li></ul><p><strong>目录结构</strong><br><img src="https://img-blog.csdn.net/20180424203923979?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>UserCustom.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.po;</span><br><span class="line"></span><br><span class="line">public class UserCustom extends User &#123;</span><br><span class="line">    //可扩展用户信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>UserQueryVo.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.mybatis.po;</span><br><span class="line"></span><br><span class="line">public class UserQueryVo &#123;</span><br><span class="line">    //这里包装所需的查询条件</span><br><span class="line"></span><br><span class="line">    //用户查询条件</span><br><span class="line">    private UserCustom userCustom;</span><br><span class="line"></span><br><span class="line">    public UserCustom getUserCustom() &#123;</span><br><span class="line">        return userCustom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserCustom(UserCustom userCustom) &#123;</span><br><span class="line">        this.userCustom = userCustom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //可包装其他的查询条件，订单，商品。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>UserMapper.xml中配置新的查询</strong><br><img src="https://img-blog.csdn.net/20180424204153986?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>UserMapperTest.java中新增测试</strong><br><img src="https://img-blog.csdn.net/20180424204301957?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>测试结果</strong><br><img src="https://img-blog.csdn.net/20180424204327547?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li><p><strong>Mybatis输出映射（掌握）</strong></p><ul><li><p><strong>一、resultType</strong></p><ul><li><strong>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。</strong></li><li>如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。</li><li>只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象</li></ul><p><strong>在上面的输入中，属于每一列都成功映射</strong><br><img src="https://img-blog.csdn.net/20180424210559929?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>当我们修改查询语句为：</strong><br><img src="https://img-blog.csdn.net/20180424210645508?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>其中id，起了别名叫做id_<br><strong>测试结果：</strong><br><img src="https://img-blog.csdn.net/20180424210723446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>很明显，由于查询条件，生日和地址为空，由于id的映射失败，导致查询id失败，只有sex一列映射成功，故查询成功（1代表男，2代表女）</p></li><li><strong>1.resultType的输出简单类型</strong><ul><li><strong>需求：</strong>用户信息的综合查询列表总数，通过查询总数和上边用户综合查询列表才可以实现分页。 </li></ul></li></ul></li></ul><p><strong>如法炮制</strong>，对mapper.xml编辑和mapper.java编辑<br>         <img src="https://img-blog.csdn.net/20180424212749871?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>         <img src="https://img-blog.csdn.net/20180424212812856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>         <strong>测试代码(复制修改)</strong><br>         <img src="https://img-blog.csdn.net/2018042421284048?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>         <strong>测试结果</strong><br>         <img src="https://img-blog.csdn.net/20180424212856266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>         <strong>总结：查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。</strong></p><ul><li><p><strong>2.resultType的输出pojo对象和pojo列表</strong></p><ul><li><strong>不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。</strong><ul><li>在mapper.java指定的方法返回值类型不一样：<ul><li>1、输出单个pojo对象，方法返回值是单个对象类型</li><li>2、输出pojo对象list，方法返回值是List&lt;简单java对象&gt;<br><img src="https://img-blog.csdn.net/20180424213406417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul></li></ul></li><li><p><strong>二、resultMap</strong></p><ul><li>mybatis中使用resultMap完成高级输出结果映射。</li><li>实例：<ul><li>1、在usermapper.xml定义resultMap<br><img src="https://img-blog.csdn.net/20180425194135238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>2、在usermapper.xml中定义查询<br><img src="https://img-blog.csdn.net/20180425194250260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>3、在usermapper.java中定义方法<br><img src="https://img-blog.csdn.net/20180425194544579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>4、编写测试方法<br><img src="https://img-blog.csdn.net/20180425194356425?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>5、测试结果<br><img src="https://img-blog.csdn.net/20180425194439135?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><strong>6、总结</strong><ul><li><strong>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功</strong>。</li><li><strong>如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。</strong></li></ul></li></ul></li></ul></li></ul><h2 id="7、Mybatis的动态sql-掌握"><a href="#7、Mybatis的动态sql-掌握" class="headerlink" title="7、Mybatis的动态sql(掌握)"></a>7、Mybatis的动态sql(掌握)</h2><ul><li>什么是动态sql？<ul><li>mybatis核心 对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。</li><li>在原来的usermapper.xml中修改<strong>用户综合查询总数</strong>为下面代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!--用户综合查询总数--&gt;</span><br><span class="line">    &lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.nuc.mybatis.po.UserQueryVo&quot;</span><br><span class="line">            resultType=&quot;int&quot;&gt;</span><br><span class="line">        select count(*) from user</span><br><span class="line">        &lt;!--where可以自动去掉第一个and--&gt;</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;userCustom!=null&quot;&gt;</span><br><span class="line">                &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt;</span><br><span class="line">                    and user.sex=#&#123;userCustom.sex&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt;</span><br><span class="line">                    and user.username=#&#123;userCustom.username&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">   - 修改测试类及测试结果</span><br><span class="line">   ![这里写图片描述](https://img-blog.csdn.net/20180425200925731?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line">   - **sql片段**</span><br><span class="line">   - 将上边实现的动态sql判断代码块抽取出来，组成一个sql片段。其它的statement中就可以引用sql片段。方便程序员进行开发</span><br><span class="line">   - 先在mapper.xml中定义一个sql片段</span><br></pre></td></tr></table></figure></li></ul></li></ul><!--sql片段    经验：基于单表来定义sql片段，这样，sql片段的可重用度就高    在sql片段中不要用where，因为你很有可能查询条件不止一个    --><pre><code>&lt;sql id=&quot;Query_user&quot;&gt;    &lt;if test=&quot;userCustom!=null&quot;&gt;        &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt;            and user.sex=#{userCustom.sex}        &lt;/if&gt;        &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt;            and user.username=#{userCustom.username}        &lt;/if&gt;    &lt;/if&gt;&lt;/sql&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 将之前的sql语句修改如下：</span><br></pre></td></tr></table></figure><!--用户综合查询总数--><pre><code>&lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.nuc.mybatis.po.UserQueryVo&quot;        resultType=&quot;int&quot;&gt;    select count(*) from user    &lt;!--where可以自动去掉第一个and--&gt;    &lt;where&gt;        &lt;!--引用sql的id，如果refid引用的sql的id不在本mapper中，则需要家其他mapper的namespace--&gt;        &lt;include refid=&quot;Query_user&quot;/&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 测试和之前的一样 </span><br><span class="line">- **foreach**</span><br><span class="line">- 向sql传递数组或List，mybatis使用foreach解析</span><br><span class="line">- 在用户查询列表和查询总数的statement中增加多个id输入查询。即实现**SELECT * FROM USER WHERE id=1 OR id=10 OR id=16**</span><br><span class="line">- 先修改sql</span><br></pre></td></tr></table></figure><p><sql id="Query_user"><br>        <if test="userCustom!=null"><br>            <if test="userCustom.sex!=null and userCustom.sex!=''"><br>                and user.sex=#{userCustom.sex}<br>            </if><br>            <if test="userCustom.username!=null and userCustom.username!=''"><br>                and user.username=#{userCustom.username}<br>            </if><br>        </if><br>        <if test="ids!=null"><br>            <!--                collection:指定输入对象集合中的属性                item：每次遍历生成的对象名                open：开始遍历拼接的串                close：结束时拼接的串                separator：每个对象的中间拼接的串                我们要实现 and(id=1 OR id=10 OR id=16)            --><br>            <foreach collection="ids" item="user_id" open="and(" close=")" separator="OR"><br>              <!--每次遍历拼接的串--><br>                id=#{user_id}<br>            </foreach><br>        </if><br>    </sql><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 添加属性，及其get set 方法</span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180425210223554?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line">- 修改测试类</span><br></pre></td></tr></table></figure></p><p>//    用户综合查询总数<br>@Test<br>    public void testFindUser() throws Exception{<br>        SqlSession sqlSession = sqlSessionFactory.openSession();<br>        //创建UserMapper的对象,mybatisCount自动调用<br>        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>        //创建包对象，设置查询条件<br>        UserQueryVo userQueryVo = new UserQueryVo();<br>        UserCustom userCustom = new UserCustom();<br>//        由于这里使用动态sql所以不设置某个值，就不会拼接在sql语句中<br>//        userCustom.setSex(“1”);<br>        userCustom.setUsername(“小明”);<br>        List<integer> list = new ArrayList&lt;&gt;();<br>        list.add(1);<br>        list.add(10);<br>        list.add(16);<br>        userQueryVo.setIds(list);<br>        userQueryVo.setUserCustom(userCustom);<br>        int count= userMapper.findUserCount(userQueryVo);<br>        System.out.println(count);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> - 测试结果</span><br><span class="line"> ![这里写图片描述](https://img-blog.csdn.net/2018042521031361?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"> sql语句成功修改！</span><br><span class="line"></span><br><span class="line">## 8、订单商品数据模型分析</span><br><span class="line">- **数据模型分析思路**</span><br><span class="line">- **1、每张表记录的数据内容**</span><br><span class="line">- 分模块对每张表记录的内容进行熟悉，相当 于你学习系统 需求（功能）的过程</span><br><span class="line">- **2、每张表重要的字段设置**</span><br><span class="line">- 非空字段、外键字段</span><br><span class="line"> - **3、数据库级别表与表之间的关系**</span><br><span class="line"> - 外键关系</span><br><span class="line"> - **4、表与表之间的业务关系**</span><br><span class="line"> - 在分析表与表之间的业务关系时一定要建立 **在某个业务意义基础上去分析。**</span><br><span class="line"> </span><br><span class="line">下来拿之前的数据库的表为例，具体字段不作说明</span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180426195542490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line">根据上面的步骤。</span><br><span class="line">**第一步：每张表记录的数据内容**</span><br><span class="line">- 用户表user：记录了购买商品的用户信息</span><br><span class="line">- 订单表：orders：记录了用户所创建的订单（购买商品的订单）</span><br><span class="line">- 订单明细表：orderdetail：记录了订单的详细信息即购买商品的信息</span><br><span class="line">- 商品表：items：记录了商品信息</span><br><span class="line">   </span><br><span class="line">   **第二步：每张表重要的字段设置**</span><br><span class="line">   **第三步：数据库级别表与表之间的关系**</span><br><span class="line">   - 表与表之间的业务关系：在分析表与表之间的业务关系时需要建立 **在某个业务意义基础上去分析。**</span><br><span class="line">  </span><br><span class="line">  先分析数据库级别之间有关系的表之间的业务关系：</span><br><span class="line">- usre和orders：</span><br><span class="line">- user---&gt;orders：一个用户可以创建多个订单，一对多</span><br><span class="line">- orders---&gt;user：一个订单只由一个用户创建，一对一</span><br><span class="line"></span><br><span class="line">- orders和orderdetail：</span><br><span class="line">- orders---&gt;orderdetail：一个订单可以包括 多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多</span><br><span class="line">- orderdetail---&gt; orders：一个订单明细只能包括在一个订单中，一对一</span><br><span class="line">- orderdetail和itesm：</span><br><span class="line">- orderdetail---&gt;itesms：一个订单明细只对应一个商品信息，一对一</span><br><span class="line">- items--&gt; orderdetail:一个商品可以包括在多个订单明细 ，一对多</span><br><span class="line"></span><br><span class="line"> **第四步：表与表之间的业务关系**</span><br><span class="line"> - 再分析数据库级别没有关系的表之间是否有业务关系：</span><br><span class="line">- orders和items：</span><br><span class="line">- orders和items之间可以通过orderdetail表建立 关系。</span><br><span class="line"></span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180426200315989?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line">## 9、高级结果集映射</span><br><span class="line"> - 一对一</span><br><span class="line"> **需求：查询订单信息，关联查询创建订单的用户信息**</span><br><span class="line"></span><br><span class="line"> **分析：**</span><br><span class="line"> - 确定查询的主表：订单表</span><br><span class="line"> - 确定查询的关联表：用户表</span><br><span class="line"> - 关联查询使用内链接？还是外链接？</span><br><span class="line"> - 由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内链接。</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  orders.*,</span><br><span class="line">  USER.username,</span><br><span class="line">  USER.sex,</span><br><span class="line">  USER.address </span><br><span class="line">FROM</span><br><span class="line">  orders,</span><br><span class="line">  USER </span><br><span class="line">WHERE orders.user_id = user.id</span><br><span class="line"> - 1、用**resultType**实现</span><br><span class="line"> - 在po包中创建：Orders类</span><br><span class="line"> - 在po包中创建：OrdersCustom类继承 Orders类</span><br><span class="line"> - 在mapper包中创建：OrdersMapperCustom接口</span><br><span class="line"> - 在mapper包中创建：OrdersMapperCustom.xml</span><br><span class="line"> - 在test包中创建：OrdersMapperTest类</span><br><span class="line"></span><br><span class="line">**Orders.java**</span><br></pre></td></tr></table></figure></integer></p><p>package com.nuc.mybatis.po;</p><p>import java.util.Date;<br>import java.util.List;</p><p>public class Orders {<br>    private Integer id;</p><pre><code>private Integer userId;private String number;private Date createtime;private String note;//用户信息private User user;//订单明细private List&lt;Orderdetail&gt; orderdetails;public Integer getId() {    return id;}public void setId(Integer id) {    this.id = id;}public Integer getUserId() {    return userId;}public void setUserId(Integer userId) {    this.userId = userId;}public String getNumber() {    return number;}public void setNumber(String number) {    this.number = number == null ? null : number.trim();}public Date getCreatetime() {    return createtime;}public void setCreatetime(Date createtime) {    this.createtime = createtime;}public String getNote() {    return note;}public void setNote(String note) {    this.note = note == null ? null : note.trim();}public User getUser() {    return user;}public void setUser(User user) {    this.user = user;}public List&lt;Orderdetail&gt; getOrderdetails() {    return orderdetails;}public void setOrderdetails(List&lt;Orderdetail&gt; orderdetails) {    this.orderdetails = orderdetails;}    </code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**OrdersCustom .java**</span><br></pre></td></tr></table></figure></p><p>package com.nuc.mybatis.po;</p><p>public class OrdersCustom extends Orders {<br>    private String username;<br>    private String sex;<br>    private String address;<br>    public String getUsername() {<br>        return username;<br>    }<br>    public void setUsername(String username) {<br>        this.username = username;<br>    }<br>    public String getSex() {<br>        return sex;<br>    }<br>    public void setSex(String sex) {<br>        this.sex = sex;<br>    }<br>    public String getAddress() {<br>        return address;<br>    }<br>    public void setAddress(String address) {<br>        this.address = address;<br>    }</p><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**OrdersMapperCustom.java**</span><br></pre></td></tr></table></figure><p>package com.nuc.mybatis.mapper;</p><p>import java.util.List;</p><p>public interface OrdersMapperCustom {<br>    public List<ordersmappercustom> findOrdersUser()throws Exception;<br>}</ordersmappercustom></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**OrdersMapperCustom .xml**</span><br></pre></td></tr></table></figure><p>&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;<br>&lt;!DOCTYPE mapper<br>        PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN”<br>        “<a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;" target="_blank" rel="noopener">http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</a></p><mapper namespace="com.nuc.mybatis.mapper.OrdersMapperCustom"><br>    <!--resultType:返回值的映射的pojo对象--><br>    <select id="findOrdersUser" resulttype="com.nuc.mybatis.po.OrdersCustom"><br>      SELECT<br>      orders.*,<br>      user.username,<br>      user.sex,<br>      user.address<br>      FROM<br>      orders,<br>      user<br>      WHERE orders.user_id = user.id<br>    </select><br><br></mapper><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**OrdersMapperTest.java**</span><br></pre></td></tr></table></figure><p>package com.nuc.mybatis.test;</p><p>import com.nuc.mybatis.mapper.OrdersMapperCustom;<br>import org.apache.ibatis.io.Resources;<br>import org.apache.ibatis.session.SqlSession;<br>import org.apache.ibatis.session.SqlSessionFactory;<br>import org.apache.ibatis.session.SqlSessionFactoryBuilder;<br>import org.junit.Before;<br>import org.junit.Test;</p><p>import java.io.InputStream;<br>import java.util.List;</p><p>public class OrdersMapperTest {<br>    private SqlSessionFactory sqlSessionFactory;<br>    @Before<br>    public void setUp() throws Exception{<br>        String resource = “SqlMapConfig.xml”;<br>        InputStream inputStream = Resources.getResourceAsStream(resource);<br>        //创建会话工厂<br>        sqlSessionFactory = new<br>                SqlSessionFactoryBuilder().build(inputStream);<br>    }<br>    @Test<br>    public void testFindOrdersUser() throws Exception {<br>        SqlSession sqlSession = sqlSessionFactory.openSession();<br>        // 创建代理对象<br>        OrdersMapperCustom ordersMapperCustom = sqlSession<br>                .getMapper(OrdersMapperCustom.class);<br>        // 调用maper的方法<br>        List<ordersmappercustom> list = ordersMapperCustom.findOrdersUser();<br>        System.out.println(list);<br>        sqlSession.close();<br>    }<br>}</ordersmappercustom></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**测试结果**</span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180426212950456?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line"> - 2、用**resultMap**实现</span><br><span class="line"> - 实现思路：使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</span><br><span class="line">  - 第一步：Orders类中添加User 的user属性。上面的代码已经添加</span><br><span class="line">  - 第二步：mapper.xml中定义ResultMap及其查询</span><br><span class="line">  - 第三步：接口中定义相应的方法</span><br><span class="line">  - 最后测试</span><br><span class="line"></span><br><span class="line">**第三步：**</span><br></pre></td></tr></table></figure><p><resultmap type="com.nuc.mybatis.po.Orders" id="OrdersUserResultMap"><br>        <!-- 配置映射的订单信息 --><br>        <!-- id：指定查询列中的唯 一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id            column：订单信息的唯 一标识 列            property：订单信息的唯 一标识 列所映射到Orders中哪个属性          --><br>        <id column="id" property="id"><br>        <result column="user_id" property="userId"><br>        <result column="number" property="number"><br>        <result column="createtime" property="createtime"><br>        <result column="note" property="note"><br>        <!-- 配置映射的关联的用户信息 --><br>        <!-- association：用于映射关联查询单个对象的信息        property：要将关联查询的用户信息映射到Orders中哪个属性         --><br>        <association property="user" javatype="com.nuc.mybatis.po.User"><br>            <!-- id：关联查询用户的唯 一标识            column：指定唯 一标识用户信息的列            javaType：映射到user的哪个属性             --><br>            <id column="user_id" property="id"><br>            <result column="username" property="username"><br>            <result column="sex" property="sex"><br>            <result column="address" property="address"><br>        </result></result></result></id></association><br>    </result></result></result></result></id></resultmap><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;!-- 查询订单关联查询用户信息，使用resultmap --&gt;</span><br><span class="line">    &lt;select id=&quot;findOrdersUserResultMap&quot; resultMap=&quot;OrdersUserResultMap&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">        orders.*,</span><br><span class="line">        USER.username,</span><br><span class="line">        USER.sex,</span><br><span class="line">        USER.address</span><br><span class="line">        FROM</span><br><span class="line">        orders,</span><br><span class="line">        USER</span><br><span class="line">        WHERE orders.user_id = user.id</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><strong>第四步</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询订单关联查询用户使用resultMap</span><br><span class="line">    public List&lt;Orders&gt; findOrdersUserResultMap()throws Exception;</span><br></pre></td></tr></table></figure></p><p><strong>测试</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testFindOrdersResultMap() throws Exception &#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    // 创建代理对象</span><br><span class="line">    OrdersMapperCustom ordersMapperCustom = sqlSession</span><br><span class="line">            .getMapper(OrdersMapperCustom.class);</span><br><span class="line">    // 调用maper的方法</span><br><span class="line">    List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserResultMap();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>总结</strong></p><ul><li><p>resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。<strong>如果没有查询结果的特殊要求建议使用resultType。</strong></p></li><li><p>resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。<strong>resultMap可以实现延迟加载，resultType无法实现延迟加载。</strong></p></li></ul><ul><li><p>一对多 </p><ul><li><p>需求：查询订单及订单明细的信息。(根据数据库模型分析的结果来查询)</p><ul><li>使用resultMap：<br><img src="https://img-blog.csdn.net/20180429162309692?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>要求：</strong>对orders映射不能出现重复记录。<br><strong>解决思路：</strong></li><li>在orders.java类中添加List&lt;&gt;,  orderDetails属性。</li><li>最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的orderDetails属性中。</li><li>映射成的orders记录数为两条（orders信息不重复）</li><li>每个orders中的orderDetails属性存储了该 订单所对应的订单明细</li></ul><p>添加属性在之前已经实现，且注释。<br>只需要配置xml文件和接口，写一个测试类即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 订单及订单明细的resultMap</span><br><span class="line">使用extends继承，不用在中配置订单信息和用户信息的映射</span><br><span class="line"> --&gt;</span><br><span class="line">    &lt;resultMap type=&quot;com.nuc.mybatis.po.Orders&quot; id=&quot;OrdersAndOrderDetailResultMap&quot; extends=&quot;OrdersUserResultMap&quot;&gt;</span><br><span class="line">        &lt;!-- 订单信息 --&gt;</span><br><span class="line">        &lt;!-- 用户信息 --&gt;</span><br><span class="line">        &lt;!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 --&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- 订单明细信息</span><br><span class="line">        一个订单关联查询出了多条明细，要使用collection进行映射</span><br><span class="line">        collection：对关联查询到多条记录映射到集合对象中</span><br><span class="line">        property：将关联查询到多条记录映射到com.nuc.mybatis.po.Orders哪个属性</span><br><span class="line">        ofType：指定映射到list集合属性中pojo的类型</span><br><span class="line">         --&gt;</span><br><span class="line">        &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.nuc.mybatis.po.Orderdetail&quot;&gt;</span><br><span class="line">            &lt;!-- id：订单明细唯 一标识</span><br><span class="line">            property:要将订单明细的唯 一标识 映射到com.nuc.mybatis.po.Orderdetail的哪个属性</span><br><span class="line">              --&gt;</span><br><span class="line">            &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!-- 查询订单关联查询用户及订单明细，使用resultmap --&gt;</span><br><span class="line">    &lt;select id=&quot;findOrdersAndOrderDetailResultMap&quot; resultMap=&quot;OrdersAndOrderDetailResultMap&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">        orders.*,</span><br><span class="line">        USER.username,</span><br><span class="line">        USER.sex,</span><br><span class="line">        USER.address,</span><br><span class="line">        orderdetail.id orderdetail_id,</span><br><span class="line">        orderdetail.items_id,</span><br><span class="line">        orderdetail.items_num,</span><br><span class="line">        orderdetail.orders_id</span><br><span class="line">        FROM</span><br><span class="line">        orders,</span><br><span class="line">        USER,</span><br><span class="line">        orderdetail</span><br><span class="line">        WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> //查询订单(关联用户)及订单明细</span><br><span class="line">    public List&lt;Orders&gt; findOrdersAndOrderDetailResultMap() throws Exception;</span><br><span class="line">@Test</span><br><span class="line">    public void testfindOrdersAndOrderDetailResultMap() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        // 创建代理对象</span><br><span class="line">        OrdersMapperCustom ordersMapperCustom = sqlSession</span><br><span class="line">                .getMapper(OrdersMapperCustom.class);</span><br><span class="line">        // 调用maper的方法</span><br><span class="line">        List&lt;Orders&gt; list = ordersMapperCustom.findOrdersAndOrderDetailResultMap();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。</li><li>使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。</li><li>多对多<ul><li><strong>需求：</strong>查询用户及用户购买商品信息。</li><li>sql语句<ul><li>查询主表是：用户表</li><li>关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：orders、orderdetail、items</li><li>SELECT<br>orders.*,<br>USER.username,<br>USER.sex,<br>USER.address,<br>orderdetail.id orderdetail_id,<br>orderdetail.items_id,<br>orderdetail.items_num,<br>orderdetail.orders_id,<br>items.name items_name,<br>items.detail items_detail,<br>items.price items_price<br>FROM<br>orders,<br>USER,<br>orderdetail,<br>items<br>WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id</li></ul></li></ul></li></ul><ul><li><p>映射思路</p><ul><li>将用户信息映射到user中。</li><li>在user类中添加订单列表属性List<orders> orderslist，将用户创建的订单映射到orderslist</orders></li><li>在Orders中添加订单明细列表属性List&lt;&gt;orderdetials，将订单的明细映射到orderdetials</li><li>在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items</li></ul></li><li><p>mapper.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 查询用户及购买的商品信息，使用resultmap --&gt;</span><br><span class="line">&lt;select id=&quot;findUserAndItemsResultMap&quot; resultMap=&quot;UserAndItemsResultMap&quot;&gt;</span><br><span class="line">    SELECT</span><br><span class="line">    orders.*,</span><br><span class="line">    USER.username,</span><br><span class="line">    USER.sex,</span><br><span class="line">    USER.address,</span><br><span class="line">    orderdetail.id orderdetail_id,</span><br><span class="line">    orderdetail.items_id,</span><br><span class="line">    orderdetail.items_num,</span><br><span class="line">    orderdetail.orders_id,</span><br><span class="line">    items.name items_name,</span><br><span class="line">    items.detail items_detail,</span><br><span class="line">    items.price items_price</span><br><span class="line">    FROM</span><br><span class="line">    orders,</span><br><span class="line">    USER,</span><br><span class="line">    orderdetail,</span><br><span class="line">    items</span><br><span class="line">    WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><p>resultMap定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 查询用户及购买的商品 --&gt;</span><br><span class="line"> &lt;resultMap type=&quot;com.nuc.mybatis.po.User&quot; id=&quot;UserAndItemsResultMap&quot;&gt;</span><br><span class="line">     &lt;!-- 用户信息 --&gt;</span><br><span class="line">     &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- 订单信息</span><br><span class="line">     一个用户对应多个订单，使用collection映射</span><br><span class="line">      --&gt;</span><br><span class="line">     &lt;collection property=&quot;ordersList&quot; ofType=&quot;com.nuc.mybatis.po.Orders&quot;&gt;</span><br><span class="line">         &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">         &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;</span><br><span class="line">         &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;</span><br><span class="line">         &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;</span><br><span class="line">         &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;</span><br><span class="line"></span><br><span class="line">         &lt;!-- 订单明细</span><br><span class="line">     一个订单包括 多个明细</span><br><span class="line">      --&gt;</span><br><span class="line">         &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.nuc.mybatis.po.Orderdetail&quot;&gt;</span><br><span class="line">             &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">             &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;</span><br><span class="line">             &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;</span><br><span class="line">             &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;</span><br><span class="line">             &lt;!-- 商品信息</span><br><span class="line">      一个订单明细对应一个商品</span><br><span class="line">       --&gt;</span><br><span class="line">             &lt;association property=&quot;items&quot; javaType=&quot;com.nuc.mybatis.po.Items&quot;&gt;</span><br><span class="line">                 &lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">                 &lt;result column=&quot;items_name&quot; property=&quot;name&quot;/&gt;</span><br><span class="line">                 &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;</span><br><span class="line">                 &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;</span><br><span class="line">             &lt;/association&gt;</span><br><span class="line">         &lt;/collection&gt;</span><br><span class="line">     &lt;/collection&gt;</span><br><span class="line"> &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></li><li><p>mapper.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询用户购买商品信息</span><br><span class="line">   public List&lt;User&gt;  findUserAndItemsResultMap()throws Exception;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong><br><img src="https://img-blog.csdn.net/20180429174426722?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><strong>多对多查询总结</strong></p><ul><li>将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量）</li><li>针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。</li><li>一对多是多对多的特例，如下需求：<ul><li>查询用户购买的商品信息，用户和商品的关系是多对多关系。<ul><li>需求1：查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)企业开发中常见明细列表，用户购买商品明细列表，使用resultType将上边查询列映射到pojo输出。</li><li>需求2：查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）使用resultMap将用户购买的商品明细列表映射到user对象中。</li></ul></li></ul></li></ul></li><li><p>总结：<strong>使用resultMap是针对那些对查询结果映射有特殊要求的功能，比如特殊要求映射成list中包括 多个list</strong></p></li><li><strong>resultMap总结</strong><ul><li>resultType：<ul><li>作用:将查询结果按照sql列名pojo属性名一致性映射到pojo中。</li><li>场合：常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。</li></ul></li><li>resultMap：<ul><li>使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。</li><li>association：<ul><li>作用：将关联查询信息映射到一个pojo对象中。</li><li>场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。</li><li><strong>使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。</strong></li></ul></li><li>collection：<ul><li>作用：将关联查询信息映射到一个list集合中。</li><li>场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。<strong>如果使用resultType无法将查询结果映射到list集合中。</strong></li></ul></li></ul></li></ul></li></ul><h2 id="10、Mybatis延迟加载"><a href="#10、Mybatis延迟加载" class="headerlink" title="10、Mybatis延迟加载"></a>10、Mybatis延迟加载</h2><ul><li><p>resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。</p><ul><li>需求：如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。</li></ul></li><li><p>延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高 数据库性能，因为查询单表要比关联查询多张表速度要快。</p></li><li><p>不使用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载？？</p><ul><li><p>实现方法如下：</p><ul><li>定义两个mapper方法：<ul><li>1、查询订单列表</li><li>2、根据用户id查询用户信息<ul><li>实现思路：先去查询第一个mapper方法，获取订单信息列表。在程序中（service），按需去调用第二个mapper方法去查询用户信息。</li></ul></li></ul></li></ul><p><strong>总之：</strong>使用延迟加载方法，先去查询简单的sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。</p></li></ul></li></ul><h2 id="11、Mybatis查询缓存"><a href="#11、Mybatis查询缓存" class="headerlink" title="11、Mybatis查询缓存"></a>11、Mybatis查询缓存</h2><ul><li>什么是查询缓存？<ul><li>mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。</li></ul></li><li>为什么要用缓存？<ul><li>如果缓存中有数据就不用从数据库中获取，大大提高系统性能。</li></ul></li><li>mybaits提供一级缓存，和二级缓存。<br><img src="https://img-blog.csdn.net/20180502105143436?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><p>一级缓存</p><ul><li>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</li><li><p><strong>工作原理</strong><br><img src="https://img-blog.csdn.net/2018050210531373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。</li><li>如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</li><li>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</li><li><p><strong>测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//mybatis默认支持一级缓存，不需要在配置文件去配置。</span><br><span class="line">    @Test</span><br><span class="line">    public void testCache1() throws Exception&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();//创建代理对象</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        //下边查询使用一个SqlSession</span><br><span class="line">        //第一次发起请求，查询id为1的用户</span><br><span class="line">        User user1 = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">//如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</span><br><span class="line">        //更新user1的信息</span><br><span class="line">        user1.setUsername(&quot;测试用户22&quot;);</span><br><span class="line">        userMapper.updateUser(user1);</span><br><span class="line">        //执行commit操作去清空缓存</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        //第二次发起请求，查询id为1的用户</span><br><span class="line">        User user2 = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>一级缓存应用</p><ul><li><p>正式开发，是将mybatis和spring进行整合开发，事务控制在service中。<br>一个service方法中包括 很多mapper方法调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service&#123;</span><br><span class="line">//开始执行时，开启事务，创建SqlSession对象</span><br><span class="line">//第一次调用mapper的方法findUserById(1)</span><br><span class="line"></span><br><span class="line">//第二次调用mapper的方法findUserById(1)，从一级缓存中取数据</span><br><span class="line">//方法结束，sqlSession关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>如果是执行两个service调用查询相同 的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。</code></pre></li></ul></li></ul></li></ul></li><li><p>二级缓存</p><ul><li>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</li><li>原理<br>  <img src="https://img-blog.csdn.net/20180502112111808?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><ul><li>首先开启mybatis的二级缓存。</li><li>sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中。</li><li>如果SqlSession3去执行相同 mapper下sql，执行commit提交，清空该 mapper下的二级缓存区域的数据。</li><li>sqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</li><li>二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。</li><li>UserMapper有一个二级缓存区域（按namespace分） ，其它mapper也有自己的二级缓存区域（按namespace分）。</li><li>每一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同 的二级缓存区域中。</li></ul></li><li><strong>开启二级缓存：</strong><ul><li>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。<br><img src="https://img-blog.csdn.net/20180502115222752?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180502115232686?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>调用pojo类实现序列化接口<br><img src="https://img-blog.csdn.net/20180502115327122?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 二级缓存测试</span><br><span class="line">  @Test</span><br><span class="line">  public void testCache2() throws Exception &#123;</span><br><span class="line">      SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">      SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">      SqlSession sqlSession3 = sqlSessionFactory.openSession();</span><br><span class="line">      // 创建代理对象</span><br><span class="line">      UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">      // 第一次发起请求，查询id为1的用户</span><br><span class="line">      User user1 = userMapper1.findUserById(1);</span><br><span class="line">      System.out.println(user1);</span><br><span class="line"></span><br><span class="line">      //这里执行关闭操作，将sqlsession中的数据写到二级缓存区域</span><br><span class="line">      sqlSession1.close();</span><br><span class="line">      </span><br><span class="line">      //使用sqlSession3执行commit()操作</span><br><span class="line">      UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);</span><br><span class="line">      User user  = userMapper3.findUserById(1);</span><br><span class="line">      user.setUsername(&quot;张明明&quot;);</span><br><span class="line">      userMapper3.updateUser(user);</span><br><span class="line">      //执行提交，清空UserMapper下边的二级缓存</span><br><span class="line">      sqlSession3.commit();</span><br><span class="line">      sqlSession3.close();</span><br><span class="line"></span><br><span class="line">      UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line">      // 第二次发起请求，查询id为1的用户</span><br><span class="line">      User user2 = userMapper2.findUserById(1);</span><br><span class="line">      System.out.println(user2);</span><br><span class="line"></span><br><span class="line">      sqlSession2.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>useCache配置</p><ul><li><p>在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。</p><figure class="highlight plain"><figcaption><span>id</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**总结：**针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。</span><br><span class="line"></span><br><span class="line"> - 刷新缓存（就是清空缓存）</span><br><span class="line"> - 在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。</span><br><span class="line"> - 设置statement配置中的flushCache=&quot;true&quot; 属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。</span><br><span class="line">如下：</span><br><span class="line">```&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot; flushCache=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。</p></li></ul></li><li><p><strong>mybatis整合ehcache</strong></p><ul><li>ehcache是一个分布式缓存框架。</li><li>分布缓存<ul><li>我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）<br><img src="https://img-blog.csdn.net/20180502131052785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统 开发。所以要<strong>使用分布式缓存对缓存数据进行集中管理</strong></li><li><p>mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p><ul><li><p>整合方法（掌握）：</p><ul><li>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。<strong>例如：</strong> mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。</li><li>加入ehcache包<br><img src="https://img-blog.csdn.net/20180502132013592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>记得添加到class</li><li>配置mapper中cache中的type为ehcache对cache接口的实现类型。<br><img src="https://img-blog.csdn.net/20180502133031610?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><p>在config目录下加入ehcache的配置文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;</span><br><span class="line">    &lt;defaultCache</span><br><span class="line">            maxElementsInMemory=&quot;1000&quot;</span><br><span class="line">            maxElementsOnDisk=&quot;10000000&quot;</span><br><span class="line">            eternal=&quot;false&quot;</span><br><span class="line">            overflowToDisk=&quot;false&quot;</span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">            diskExpiryThreadIntervalSeconds=&quot;120&quot;</span><br><span class="line">            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;</span><br><span class="line">    &lt;/defaultCache&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><ul><li><strong>二级缓存应用场景:</strong><br>  对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。<br><strong>实现方法如下：</strong>通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。</li></ul><ul><li><strong>二级缓存局限性</strong><br> mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</li></ul><h2 id="12、Mybatis和Spring整合-掌握"><a href="#12、Mybatis和Spring整合-掌握" class="headerlink" title="12、Mybatis和Spring整合(掌握)"></a>12、Mybatis和Spring整合(掌握)</h2><ul><li><strong>整合思路</strong><ul><li>需要spring通过单例方式管理SqlSessionFactory。</li><li>spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession。（spring和mybatis整合自动完成）</li><li>持久层的mapper都需要由spring进行管理。</li></ul></li><li><strong>整合环境</strong><ul><li>创建一个新的java工程（接近实际开发的工程结构）</li><li>jar包：<ul><li>mybatis3.2.7的jar包</li><li>spring3.2.0的jar包</li><li>mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供。<br><img src="https://img-blog.csdn.net/20180502165235383?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>项目源码见链接: <a href="https://pan.baidu.com/s/1yos2TcC_TRCPWUJ_-Wnd3Q" target="_blank" rel="noopener">密码: vcae</a> </li></ul></li></ul></li></ul><h2 id="13、Mybatis逆向工程"><a href="#13、Mybatis逆向工程" class="headerlink" title="13、Mybatis逆向工程"></a>13、Mybatis逆向工程</h2><ul><li>什么是逆向工程<ul><li>mybaits需要程序员自己编写sql语句，mybatis官方提供逆向工程 可以针对单表自动生成mybatis执行所需要的代码（mapper.java,mapper.xml、po..）</li><li>企业实际开发中，常用的逆向工程方式：由于数据库的表生成java代码。</li></ul></li></ul><p>mybatis的项目源码<a href="https://pan.baidu.com/s/1_7726eiziGRnzX1sAIOMWQ" target="_blank" rel="noopener">密码: b54x</a><br>mybatis的文档教程<a href="https://pan.baidu.com/s/1kDKJTw5TEFoXm4LrEIn02g" target="_blank" rel="noopener">密码: pbvf</a><br>mybatis+springMVC的视频教程<a href="http://www.icoolxue.com/album/show/216" target="_blank" rel="noopener">mybatis+springMVC</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC学习笔记🍂</title>
      <link href="/2018/04/10/springmvc/"/>
      <url>/2018/04/10/springmvc/</url>
      
        <content type="html"><![CDATA[<p>#SpringMVC</p><hr><p>##1、什么是SpringMVC？</p><ul><li><strong>springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</strong></li><li>springmvc是一个基于mvc的web框架。<br><img src="https://img-blog.csdn.net/20180503140031318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><strong>mvc</strong><ul><li>mvc在b/s系统 下的应用：<br><img src="https://img-blog.csdn.net/20180503140124314?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>springMVC框架<br><img src="https://img-blog.csdn.net/20180503140150984?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>框架执行流程</strong><ul><li>1、用户发送请求至前端控制器DispatcherServlet</li><li>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>5、执行处理器(Controller，也叫后端控制器)。</li><li>6、Controller执行完成返回ModelAndView</li><li>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>9、ViewReslover解析后返回具体View</li><li>10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>11、DispatcherServlet响应用户</li></ul></li></ul></li></ul><p>##2、SpringMVC框架原理(掌握)</p><ul><li>前端控制器DispatcherServlet（不需要程序员开发）<ul><li>作用接收请求，响应结果，相当于转发器，中央处理器。有了DispatcherServlet减少了其它组件之间的耦合度。</li></ul></li><li>处理器映射器HandlerMapping(不需要程序员开发)<ul><li>作用：根据请求的url查找Handler</li></ul></li><li>处理器适配器HandlerAdapter<ul><li>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler</li></ul></li><li>处理器Handler <strong>(需要程序员开发)</strong><ul><li>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</li></ul></li><li>视图解析器View resolver(不需要程序员开发)<ul><li>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）</li></ul></li><li>视图View <strong>(需要程序员开发)</strong><ul><li>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</li></ul></li></ul><p>##3、SpringMVC入门程序</p><ul><li>需求<ul><li>以案例作为驱动。springmvc和mybaits使用一个案例（商品订单管理）</li><li>功能需求：商品列表查询</li></ul></li><li>环境准备<ul><li><strong>数据库</strong>还是使用mybatis的数据。(mybatis的由浅入深教程开篇有下载地址) </li><li><strong>java环境：</strong> jdk(9)，ide(idea)</li><li><strong>jar包：</strong> spring所有jar（一定包括spring-webmvc.RELEASE.jar）这个jar包，版本的话<strong>个人认为当前版本的上一个大版本的最后一个小版本更合适</strong>，因为这样实时性和稳定性都不会太差</li></ul></li><li><strong>入门程序的目的：</strong> 对前端控制器，处理器映射器，处理器适配器，视图解析器的加深学习</li><li><p>接下来开始写程序：</p><ul><li>创建java web项目，引入相应的jar包打开数据库</li><li>在web.xml中配置前端控制器</li><li>classpath下的springmvc.xml中配置处理器适配器</li><li>开发Handler</li><li>视图编写</li><li>Handler</li><li>配置处理器映射器</li><li><p>配置视图解析器</p><p><strong>部署调试：</strong></p></li><li>正常调试：<br><img src="https://img-blog.csdn.net/20180508101406844?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>异常调试：<br>  处理器映射器根据url找不到Handler，报下边的错误。说明url错误。<br>  <img src="https://img-blog.csdn.net/20180508101753122?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  接下来我们修改jsp视图的地址<br>  <img src="https://img-blog.csdn.net/20180508101855733?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  处理器映射器根据url找到了Handler，转发的jsp页面找到，报下边的错误，说明jsp页面地址错误了。<strong>注意WEB-INF被修改为WEB-IF</strong></li></ul></li><li><p>非注解的处理器映射器和处理器适配器</p><ul><li><strong>非注解处理器映射器</strong>：<ul><li>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</li></ul></li><li><p>另一个映射器:</p><ul><li>org.springframework.web.servlet.handler.SimpleUrlHandlerMapping</li></ul><p>修改springmvc.xml文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </span><br><span class="line">http://www.springframework.org/schema/mvc </span><br><span class="line">http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </span><br><span class="line">http://www.springframework.org/schema/context </span><br><span class="line">http://www.springframework.org/schema/context/spring-context-3.2.xsd </span><br><span class="line">http://www.springframework.org/schema/aop </span><br><span class="line">http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </span><br><span class="line">http://www.springframework.org/schema/tx </span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置Handler --&gt;</span><br><span class="line">&lt;bean id=&quot;itemsController1&quot; name=&quot;/queryItems.action&quot; class=&quot;cn.itcast.ssm.controller.ItemsController1&quot; /&gt;</span><br><span class="line">&lt;!--配置另一个handler--&gt;</span><br><span class="line">&lt;bean id=&quot;itemsController2&quot; class=&quot;cn.itcast.ssm.controller.ItemsController2&quot; /&gt;</span><br><span class="line">&lt;!-- 处理器映射器 将bean的name作为url进行查找 ，需要在配置Handler时指定beanname（就是url）</span><br><span class="line">所有的映射器都实现 HandlerMapping接口。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 处理器适配器 所有处理器适配器都实现 HandlerAdapter接口 --&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简单url映射  --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span><br><span class="line">&lt;property name=&quot;mappings&quot;&gt;</span><br><span class="line">&lt;props&gt;</span><br><span class="line">&lt;!-- 对itemsController1进行url映射，url是/queryItems1.action --&gt;</span><br><span class="line">&lt;prop key=&quot;/queryItems1.action&quot;&gt;itemsController1&lt;/prop&gt;</span><br><span class="line">&lt;prop key=&quot;/queryItems2.action&quot;&gt;itemsController1&lt;/prop&gt;</span><br><span class="line">&lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 视图解析器</span><br><span class="line">解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>测试：<br>    <img src="https://img-blog.csdn.net/2018050810274532?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>        <strong>由此可见：多个映射器可以并存，前端控制器判断url能让哪些映射器映射，就让正确的映射器处理</strong></p><ul><li><strong>非注解处理器适配器</strong><ul><li>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter<br>要求编写的Handler实现 Controller接口。</li><li>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter<br>要求编写的Handler实现 HttpRequestHandler接口。<br>在controller包下新增ItemsController2.java</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.ssm.controller;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.HttpRequestHandler;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">import cn.itcast.ssm.po.Items;</span><br><span class="line"></span><br><span class="line">public class ItemsController2 implements HttpRequestHandler &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void handleRequest(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">//调用service查找 数据库，查询商品列表，这里使用静态数据模拟</span><br><span class="line">List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;();</span><br><span class="line">//向list中填充静态数据</span><br><span class="line"></span><br><span class="line">Items items_1 = new Items();</span><br><span class="line">items_1.setName(&quot;联想笔记本&quot;);</span><br><span class="line">items_1.setPrice(6000f);</span><br><span class="line">items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;);</span><br><span class="line"></span><br><span class="line">Items items_2 = new Items();</span><br><span class="line">items_2.setName(&quot;苹果手机&quot;);</span><br><span class="line">items_2.setPrice(5000f);</span><br><span class="line">items_2.setDetail(&quot;iphone6苹果手机！&quot;);</span><br><span class="line"></span><br><span class="line">itemsList.add(items_1);</span><br><span class="line">itemsList.add(items_2);</span><br><span class="line">//设置模型数据</span><br><span class="line">request.setAttribute(&quot;itemsList&quot;, itemsList);</span><br><span class="line">//设置转发的视图</span><br><span class="line">request.getRequestDispatcher(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;).forward(request, response);</span><br><span class="line">//使用此方法可以通过修改response，设置响应的数据格式，比如响应json数据</span><br><span class="line">/*</span><br><span class="line">response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">response.setContentType(&quot;application/json;charset=utf-8&quot;);</span><br><span class="line">response.getWriter().write(&quot;json串&quot;);*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DispatcherSerlvet.properties<br><img src="https://img-blog.csdn.net/20180508103858676?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>前端控制器从上边的文件中加载处理映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，使用默认加载的。</strong></li><li><p><strong>注解的处理器映射器和处理器适配器</strong></p><ul><li>在spring3.1之前使用<br>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping注解映射器。</li></ul><ul><li><p>在spring3.1之后使用<br>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。</p></li><li><p>在spring3.1之前使用<br>org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter注解适配器。</p></li><li><p>在spring3.1之后使用<br>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器。</p></li><li><p>配置注解映射器和适配器<br><img src="https://img-blog.csdn.net/20180508164411403?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置</span><br><span class="line">mvc:annotation-driven默认加载很多的参数绑定方法，</span><br><span class="line">比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter</span><br><span class="line">实际开发时使用mvc:annotation-driven</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;!-- &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; --&gt;</span><br></pre></td></tr></table></figure><ul><li>开发注解Handler<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.ssm.controller;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">import cn.itcast.ssm.po.Items;</span><br><span class="line"></span><br><span class="line">//使用Controller标识 它是一个控制器</span><br><span class="line">@Controller</span><br><span class="line">public class ItemsController3 &#123;</span><br><span class="line">//注解开发Handler</span><br><span class="line"></span><br><span class="line">//商品查询列表</span><br><span class="line">//@RequestMapping实现 对queryItems方法和url进行映射，一个方法对应一个url</span><br><span class="line">//一般建议将url和方法写成一样</span><br><span class="line">@RequestMapping(&quot;/queryItems&quot;)</span><br><span class="line">public ModelAndView queryItems()throws Exception&#123;</span><br><span class="line"></span><br><span class="line">//调用service查找 数据库，查询商品列表，这里使用静态数据模拟</span><br><span class="line">List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;();</span><br><span class="line">//向list中填充静态数据</span><br><span class="line"></span><br><span class="line">Items items_1 = new Items();</span><br><span class="line">items_1.setName(&quot;联想笔记本3&quot;);</span><br><span class="line">items_1.setPrice(6000f);</span><br><span class="line">items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！3&quot;);</span><br><span class="line"></span><br><span class="line">Items items_2 = new Items();</span><br><span class="line">items_2.setName(&quot;苹果手机3&quot;);</span><br><span class="line">items_2.setPrice(5000f);</span><br><span class="line">items_2.setDetail(&quot;iphone6苹果手机！3&quot;);</span><br><span class="line"></span><br><span class="line">itemsList.add(items_1);</span><br><span class="line">itemsList.add(items_2);</span><br><span class="line"></span><br><span class="line">//返回ModelAndView</span><br><span class="line">ModelAndView modelAndView =  new ModelAndView();</span><br><span class="line">//相当 于request的setAttribut，在jsp页面中通过itemsList取数据</span><br><span class="line">modelAndView.addObject(&quot;itemsList&quot;, itemsList);</span><br><span class="line"></span><br><span class="line">//指定视图</span><br><span class="line">//下边的路径，如果在视图解析器中配置jsp路径的前缀和jsp路径的后缀，修改为</span><br><span class="line">//modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);</span><br><span class="line">//上边的路径配置可以不在程序中指定jsp路径的前缀和jsp路径的后缀</span><br><span class="line">modelAndView.setViewName(&quot;items/itemsList&quot;);</span><br><span class="line">return modelAndView;</span><br><span class="line">&#125;</span><br><span class="line">//定义其它的方法</span><br><span class="line">//商品添加</span><br><span class="line">//商品修改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在spring容器中加载Handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对于注解的Handler可以单个配置</span><br><span class="line">实际开发中建议使用组件扫描</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;!-- &lt;bean class=&quot;cn.itcast.ssm.controller.ItemsController3&quot; /&gt; --&gt;</span><br><span class="line">&lt;!-- 可以扫描controller、service、...</span><br><span class="line">这里让扫描controller，指定controller的包</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;cn.itcast.ssm.controller&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></li><li><p>部署测试<br><img src="https://img-blog.csdn.net/20180508164816595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>入门总结：</strong></p></li><li>前端控制器配置：<ul><li>第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析</li><li>第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析<br>使用此种方式可以实现 RESTful风格的url</li></ul></li><li>处理器映射器：<ul><li>非注解处理器映射器（了解）</li><li>注解的处理器映射器（掌握）<ul><li>对标记@Controller类中标识有@RequestMapping的方法进行映射</li><li>在@RequestMapping里边定义映射的url。使用注解的映射器不用在xml中配置url和Handler的映射关系。</li></ul></li></ul></li><li><p>处理器适配器：</p><ul><li>非注解处理器适配器（了解）</li><li>注解的处理器适配器（掌握）<ul><li>注解处理器适配器和注解的处理器映射器是配对使用。理解为不能使用非注解映射器进行映射。</li></ul></li></ul><p>入门程序源代码下载<a href="https://pan.baidu.com/s/1PCxshg3msA0KcjVknq88tg" target="_blank" rel="noopener"> 密码: msiy</a></p></li></ul></li></ul><p>##4、SpringMVC和Mybatis整合(掌握)</p><ul><li>需求：使用springmvc和mybatis完成商品列表查询。</li><li>ssm系统架构<br><img src="https://img-blog.csdn.net/20180508171920372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>整合思路<ul><li>第一步：整合dao层<ul><li>mybatis和spring整合，通过spring管理mapper接口。</li><li>使用mapper的扫描器自动扫描mapper接口在spring中进行注册。<ul><li>第二步：整合service层</li><li>通过spring管理 service接口。</li><li>使用配置方式将service接口配置在spring配置文件中。</li><li>实现事务控制。</li></ul></li></ul></li><li>第三步：整合springmvc<ul><li>由于springmvc是spring的模块，不需要整合。</li></ul></li></ul></li><li><p>开发环境</p><ul><li>基本和入门程序的差不多，只是jar包的不同</li><li><p>所需要的jar包：</p><ul><li>springmvc3.2的jar包</li><li>spring3.2的jar包</li><li>数据库驱动包：mysql5.1</li><li>mybatis的jar包</li><li>mybatis和spring整合包</li><li>log4j包</li><li>dbcp数据库连接池包</li><li>jstl包</li></ul><p>之后我会上传源码。</p></li></ul></li><li>开发<ul><li>项目目录<br><img src="https://img-blog.csdn.net/20180508173529972?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>整合dao<ul><li>配置sqlMapConfig.xml</li><li>配置applicationContext-dao.xml<ul><li>数据源，SqlSessionFactory，mapper扫描器<ul><li>逆向工程生成po类及mapper(单表增删改查)</li><li>ItemsMapperCustom.xml和ItemsMapperCustom.java</li></ul></li></ul></li></ul></li><li>整合service<ul><li>定义service接口</li><li>在spring容器配置service(applicationContext-service.xml)</li><li>事务控制(applicationContext-transaction.xml)</li></ul></li><li>整合springmvc<ul><li>创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。</li><li>配置前端控制器</li><li>编写controller</li><li>编写jsp</li><li>加载spring容器（web.xml中）</li></ul></li></ul></li></ul><p>##5、SpringMVC注解开发</p><ul><li>常用的注解学习<ul><li><strong>@controller</strong><ul><li>这个注解必须要加，作用标识类是一个Handler处理器。</li></ul></li><li><strong>@RequestMapping</strong><ul><li>URL映射定义controller方法对应的URL，进行处理器映射使用。</li><li>窄化请求映射<br><img src="https://img-blog.csdn.net/20180514145432383?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>限制http请求方法出于安全性考虑，对http的链接进行方法限制。如果限制请求为post方法，进行get请求，报错：<br><img src="https://img-blog.csdn.net/20180514145537536?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li><strong>@RequestParam</strong><ul><li>通过@RequestParam对简单类型的参数进行绑定。</li><li>如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。</li><li>如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。</li><li>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，报下边错误：<br><img src="https://img-blog.csdn.net/20180514151002156?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul></li><li><p>controller方法的返回值</p><ul><li>返回ModelAndView<ul><li>需要方法结束时，定义ModelAndView，将model和view分别进行设置。</li></ul></li><li>返回string<ul><li>如果controller方法返回string：<ul><li>表示返回逻辑视图名。真正视图(jsp路径)=前缀+逻辑视图名+后缀<br><img src="https://img-blog.csdn.net/2018051414580654?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> </li><li>表示redirect重定向<ul><li>商品修改提交后，重定向到商品查询列表。</li><li>redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享）<br><img src="https://img-blog.csdn.net/20180514150030681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>表示forward页面转发<ul><li>通过forward进行页面转发，浏览器地址栏url不变，request可以共享。<br><img src="https://img-blog.csdn.net/20180514150051742?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul></li></ul></li><li><p>返回void</p><ul><li><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><ul><li><p>使用request转向页面，如下：</p><ul><li>request.getRequestDispatcher(“页面路径”).forward(request, response);</li></ul></li><li><p>也可以通过response页面重定向：</p><ul><li>response.sendRedirect(“url”)</li></ul></li><li><p>也可以通过response指定响应结果，例如响应json数据如下：</p><ul><li>response.setCharacterEncoding(“utf-8”);<br>response.setContentType(“application/json;charset=utf-8”);<br>response.getWriter().write(“json串”);</li></ul></li></ul></li></ul></li></ul></li><li><p>参数绑定（简单类型，pojo）</p><ul><li>spring参数绑定过程<ul><li>从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。</li><li>springmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变更接收！！！！<br><img src="https://img-blog.csdn.net/20180514150449905?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>默认支持的类型<br>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。<ul><li>HttpServletRequest<br>通过request对象获取请求信息</li><li>HttpServletResponse<br>通过response处理响应信息</li><li>HttpSession<br>通过session对象得到session中存放的对象</li><li>Model/ModelMap<br>model是一个接口，modelMap是一个接口实现 。<br>作用：将model数据填充到request域。</li></ul></li><li>pojo绑定<ul><li>页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo</li><li>页面定义：<br><img src="https://img-blog.csdn.net/20180514151211104?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>controller的pojo形参的定义：<br><img src="https://img-blog.csdn.net/20180514151221520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul></li><li><p>自定义参数绑定实现日期类型绑定（掌握）</p><ul><li><p>对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。将请求日期数据串传成 日期类型，要转换的日期类型和pojo中日期属性的类型保持一致<br><img src="https://img-blog.csdn.net/20180514151440126?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>所以自定义参数绑定将日期串转成java.util.Date类型。<br>需要向处理器适配器中注入自定义的参数绑定组件。</p><p> 自定义日期类型绑定：<br> <img src="https://img-blog.csdn.net/20180514151544730?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 配置：<br> <img src="https://img-blog.csdn.net/20180514151559817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></li></ul></li></ul><p>##6、SpringMVC和Struts2的区别</p><ul><li>pringmvc基于方法开发的，struts2基于类开发的。</li><li>springmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method。方法执行结束，形参数据销毁。springmvc的controller开发类似service开发。</li><li>springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。</li><li>经过实际测试，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl。</li></ul><p>##7、SpringMVC参数绑定(集合类型)</p><ul><li>批量删除<ul><li>关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。<br><img src="https://img-blog.csdn.net/20180514152340285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180514152354431?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>list绑定<ul><li>controller方法定义：<br>1、进入批量商品修改页面(页面样式参考商品列表实现)<br>2、批量修改商品提交：使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义list&lt;&gt;属性<br><img src="https://img-blog.csdn.net/20180514152622844?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180514152634438?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>map绑定<ul><li>也通过在包装pojo中定义map类型属性。</li><li>在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。</li></ul></li></ul><p>包装类中定义Map对象如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Public class QueryVo &#123;</span><br><span class="line">private Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;();</span><br><span class="line">  //get/set方法..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>页面定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;学生信息：&lt;/td&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">姓名：&lt;inputtype=&quot;text&quot;name=&quot;itemInfo[&apos;name&apos;]&quot;/&gt;</span><br><span class="line">年龄：&lt;inputtype=&quot;text&quot;name=&quot;itemInfo[&apos;price&apos;]&quot;/&gt;</span><br><span class="line">.. .. ..</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure></p><p>Contrller方法定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String useraddsubmit(Model model,QueryVo queryVo)throws Exception&#123;</span><br><span class="line">System.out.println(queryVo.getStudentinfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##8、SpringMVC数据回显</p><ul><li>什么数据回显<br>提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面</li><li>pojo数据回显方法<ul><li>1、springmvc默认对pojo数据进行回显。<ul><li>pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）</li><li>使用@ModelAttribute指定pojo回显到页面在request中的key</li></ul></li><li>2、@ModelAttribute还可以将方法的返回值传到页面<ul><li>在商品查询列表页面，通过商品类型查询商品信息。</li><li>在controller中定义商品类型查询方法，最终将商品类型传到页面。<br><img src="https://img-blog.csdn.net/20180514154043229?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180514154052806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>3、使用最简单方法使用model，可以不用@ModelAttribute<br><img src="https://img-blog.csdn.net/20180514154214540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>5.3简单类型数据回显<ul><li>使用最简单方法使用model。</li><li>model.addAttribute(“id”, id);</li></ul></li></ul><p>##9、SpringMVC异常处理</p><ul><li>异常处理思路<ul><li>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</li><li>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：<br><img src="https://img-blog.csdn.net/20180514160532197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。</li></ul></li><li>自定义异常<ul><li>对不同的异常类型定义异常类，继承Exception。需要时抛出此类异常<br><img src="https://img-blog.csdn.net/20180514160749822?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>全局异常开发处理<ul><li>思路：<br>系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。</li><li>全局异常处理器处理思路：<ul><li>解析出异常类型</li><li>如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示</li><li>如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）</li><li>springmvc提供一个HandlerExceptionResolver接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ModelAndView resolveException(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, Object handler, Exception ex) &#123;</span><br><span class="line">//handler就是处理器适配器要执行Handler对象（只有method）</span><br><span class="line"></span><br><span class="line">//解析出异常类型</span><br><span class="line">//如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示</span><br><span class="line">//String message = null;</span><br><span class="line">//if(ex instanceof CustomException)&#123;</span><br><span class="line">//message = ((CustomException)ex).getMessage();</span><br><span class="line">//&#125;else&#123;</span><br><span class="line">////如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）</span><br><span class="line">//message=&quot;未知错误&quot;;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//上边代码变为</span><br><span class="line">CustomException customException = null;</span><br><span class="line">if(ex instanceof CustomException)&#123;</span><br><span class="line">customException = (CustomException)ex;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">customException = new CustomException(&quot;未知错误&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//错误信息</span><br><span class="line">String message = customException.getMessage();</span><br><span class="line"></span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line"></span><br><span class="line">//将错误信息传到页面</span><br><span class="line">modelAndView.addObject(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">//指向错误页面</span><br><span class="line">modelAndView.setViewName(&quot;error&quot;);</span><br><span class="line"></span><br><span class="line">return modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>错误页面<br><img src="https://img-blog.csdn.net/20180514161246169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在springmvc.xml配置全局异常处理器<br><img src="https://img-blog.csdn.net/20180514161233155?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>异常测试（抛出）</p><ul><li><p>在controller、service、dao中任意一处需要手动抛出异常。<br>如果是程序中手动抛出的异常，在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。</p><ul><li>在商品修改的controller方法中抛出异常<br><img src="https://img-blog.csdn.net/20180514161510497?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><p>在service接口中抛出异常：<br><img src="https://img-blog.csdn.net/2018051416153064?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如果与业务功能相关的异常，建议在service中抛出异常。<br>与业务功能没有关系的异常，建议在controller中抛出。</p><p>   上边的功能，建议在service中抛出异常。<br>##9、SpringMVC上传图片</p></li></ul></li></ul><p>##10、SpringMVC json数据交互</p><ul><li>为什么要进行json数据交互<ul><li>json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。<br>比如：webservice接口，传输json数据.</li></ul></li><li>springmvc进行json交互<br><img src="https://img-blog.csdn.net/20180515152044562?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>1、请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。<br>2、请求key/value、输出json。此方法比较常用。</li><li>环境准备<ul><li>加载json转的jar包<ul><li>springmvc中使用jackson的包进行json转换（@requestBody和@responseBody使用下边的包进行json转），如下：<br><img src="https://img-blog.csdn.net/20180515152338486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul></li><li><p>配置json转换器</p><ul><li><p>在注解适配器中加入messageConverters</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注解适配器 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</span><br><span class="line">&lt;property name=&quot;messageConverters&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--注意：如果使用&lt;mvc:annotation-driven /&gt; 则不用定义上边的内容。--&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">##11、SpringMVC RESTful支持</span><br><span class="line"> - 什么是RESTful</span><br><span class="line"> - RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用</span><br><span class="line"> - RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。</span><br><span class="line"> - 1、对url进行规范，写RESTful格式的url</span><br><span class="line"> - 非REST的url：http://...../queryItems.action?id=001&amp;type=T01</span><br><span class="line"> - REST的url风格：http://..../items/001</span><br><span class="line"> - 特点：url简洁，将参数通过url传到服务端</span><br><span class="line"> - 2、http的方法规范</span><br><span class="line"> - 不管是删除、添加、更新。。使用url是一致的，如果进行删除，需要设置http的方法为delete，同理添加。。。</span><br><span class="line"> - 后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。</span><br><span class="line"></span><br><span class="line">  - 3、对http的contentType规范</span><br><span class="line">  - 请求时指定contentType，要json数据，设置成json格式的type。。</span><br><span class="line">##12、SpringMVC拦截器</span><br><span class="line"> - 定义配置</span><br><span class="line"> - 拦截定义</span><br><span class="line"> - 定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。</span><br></pre></td></tr></table></figure><p>public class HandlerInterceptor1 implements HandlerInterceptor {<br> //进入 Handler方法之前执行<br> //用于身份认证、身份授权<br> //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行<br> @Override<br> public boolean preHandle(HttpServletRequest request,</p><pre><code>    HttpServletResponse response, Object handler) throws Exception {    //return false表示拦截，不向下执行//return true表示放行return false;</code></pre><p> }<br> //进入Handler方法之后，返回modelAndView之前执行<br> //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图<br> @Override<br> public void postHandle(HttpServletRequest request,</p><pre><code>HttpServletResponse response, Object handler,ModelAndView modelAndView) throws Exception {        </code></pre><p> }<br> //执行Handler完成执行此方法<br> //应用场景：统一异常处理，统一日志处理<br> @Override<br> public void afterCompletion(HttpServletRequest request,</p><pre><code>HttpServletResponse response, Object handler, Exception ex)throws Exception {</code></pre><p> }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 拦截配置</span><br><span class="line"> - 针对HandlerMapping配置：</span><br><span class="line"> </span><br><span class="line">springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该 拦截器。</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"><br>    <property name="interceptors"><br>        <list><br>            <ref bean="handlerInterceptor1"><br>            <ref bean="handlerInterceptor2"><br>        </ref></ref></list><br>    </property><br></bean><br>    <bean id="handlerInterceptor1" class="springmvc.intercapter.HandlerInterceptor1"><br>    <bean id="handlerInterceptor2" class="springmvc.intercapter.HandlerInterceptor2"><br><code>`</code><br>        一般不推荐使用。</bean></bean></p><pre><code>- 类似全局的拦截器</code></pre><p>springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。<br>    <img src="https://img-blog.csdn.net/20180515163838504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li><p>多拦截器测试</p><ul><li><p>编写两个拦截器</p><ul><li><p>两个拦截器都放行</p><p>  HandlerInterceptor1…preHandle<br>HandlerInterceptor2…preHandle<br>HandlerInterceptor2…postHandle<br>HandlerInterceptor1…postHandle<br>HandlerInterceptor2…afterCompletion<br>HandlerInterceptor1…afterCompletion</p></li><li><p>总结：<br>preHandle方法按顺序执行，<br>postHandle和afterCompletion按拦截器配置的逆向顺序执行。</p></li><li><p>拦截器1放行，拦截器2不放行<br>HandlerInterceptor1…preHandle<br>HandlerInterceptor2…preHandle<br>HandlerInterceptor1…afterCompletion</p></li><li><p>总结：<br>拦截器1放行，拦截器2 preHandle才会执行。</p><p> 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。</p><p> 只要有一个拦截器不放行，postHandle不会执行。</p></li><li><p>拦截器1不放行，拦截器2不放行<br>HandlerInterceptor1…preHandle</p><p> 拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。<br>拦截器1 preHandle不放行，拦截器2不执行。</p></li></ul></li></ul></li></ul><ul><li><p>小结</p><ul><li><p>根据测试结果，对拦截器应用。</p><p> 比如：统一日志处理拦截器，需要该 拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。</p><p> 比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限）</p></li></ul></li></ul><h2 id="13、springmvc校验"><a href="#13、springmvc校验" class="headerlink" title="13、springmvc校验"></a>13、springmvc校验</h2><ul><li>校验理解<ul><li>项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。</li><li>服务端校验：<ul><li>控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用）</li><li>业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。</li><li>持久层dao：一般是不校验的。</li></ul></li></ul></li><li>springmvc校验需求<ul><li>springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。</li></ul></li><li>校验思路：<ul><li>页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。</li></ul></li><li>具体需求：<ul><li>商品修改，添加校验（校验商品名称长度，生产日期的非空校验），如果校验出错，在商品修改页面显示错误信息。</li></ul></li><li>环境：<br> <img src="https://img-blog.csdn.net/20180514153110638?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>配置校验器<br><img src="https://img-blog.csdn.net/20180514153153580?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>校验器注入到处理器适配器中<br><img src="https://img-blog.csdn.net/20180514153224244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>在pojo中添加校验规则<ul><li>在ItemsCustom.java中添加校验规则：<br><img src="https://img-blog.csdn.net/20180514153355394?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li><li>CustomValidationMessages.properties文件<br> <img src="https://img-blog.csdn.net/20180514153448940?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><p>捕获校验错误信息<br> <img src="https://img-blog.csdn.net/20180514153551650?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 在需要校验的pojo前边添加@Validated，在需要校验的pojo后边添加BindingResult bindingResult接收校验出错信息</p><p> 注意：@Validated和BindingResult bindingResult是配对出现，并且形参顺序是固定的（一前一后）。</p></li><li>在页面显示校验错误信息<br>  <img src="https://img-blog.csdn.net/2018051415371663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  <img src="https://img-blog.csdn.net/20180514153728671?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>项目源码<a href="https://pan.baidu.com/s/17gBD_MB9ONQopu8qyDgNyg" target="_blank" rel="noopener"> 密码: cyv3</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring学习笔记🍂</title>
      <link href="/2018/04/04/spring/"/>
      <url>/2018/04/04/spring/</url>
      
        <content type="html"><![CDATA[<p>#一、spring是什么</p><ul><li><p>Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架</p></li><li><p><a href="https://spring.io/" target="_blank" rel="noopener">spring官网</a></p></li><li><a href="https://baike.baidu.com/item/spring/85061?fr=aladdin" target="_blank" rel="noopener">spring百度百科</a></li><li><a href="https://projects.spring.io/spring-framework/" target="_blank" rel="noopener">spring-framework</a><br>#二、spring快速入门</li><li><p><strong>什么是spring？</strong></p><ul><li>首先我们了解到struts是web框架（jsp/action/actionform）</li><li>hibernate是 orm框架处于持久层</li><li><p>spring是容器框架，用于配置bean，并维护bean之间的关系的框架</p><ul><li>spring中的<strong>bean</strong>：是一个很重要的概念，这里的bean可以是Java中的任何一种对象：JavaBean/service/action/数据源/dao等等</li><li>spring中的<strong>ioc</strong>（inverse of control 控制反转）</li><li><p>spring中的<strong>di</strong>（dependency injection 依赖注入）<br>接下来看一个层次框架图：<br><img src="https://img-blog.csdn.net/20180415151535222?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>说明：</p><ul><li><strong>web层：</strong> struts充当web层，接管jsp，action，表单，主要体现出mvc的<strong>数据输入</strong>，<strong>数据的处理</strong>，<strong>数据</strong>的显示分离</li><li><strong>model层：</strong> model层在概念上可以理解为包含了<strong>业务层，dao层，持久层</strong>，需要注意的是，一个项目中，不一定每一个层次都有</li><li><strong>持久层：</strong>体现oop，主要解决关系模型和对象模型之间的<strong>阻抗</strong></li></ul></li></ul></li></ul></li><li><p><strong>入门项目</strong>：</p><ul><li>创建java项目（web中也可以使用）</li><li>创建lib文件夹引入spring的开发最小包（最小配置，spring.jar（该包把最常用的包都包括），commons-logging.jar（日志包））</li><li>创建配置文件，一般在src目录下</li><li>配置bean<br><img src="https://img-blog.csdn.net/20180415162059434?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>说明：<code>&lt;bean&gt;&lt;/bean&gt;</code>这对标签元素的作用：<strong>当我们加载spring框架时，spring就会自动创建一个bean对象，并放入内存</strong>相当于我们常规的new一个对象，而<code>&lt;property&gt;&lt;/property&gt;</code>中的value则是实现了“<strong>对象.set方法</strong>”，这里也体现了注入了概念</li><li><p>然后在java文件（测试文件）中调用</p><p>接下来看具体的项目：<br><img src="https://img-blog.csdn.net/20180415161239213?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这是我的目录结构"><br>说明：这是我的目录结构，其中我使用了ide整合了jar包，如果是手动创建时只需将jar包导入到项目里即可</p><p><strong>User.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Bean;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;+ name);</span><br><span class="line">        return &quot;true&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>抛开spring框架，使用传统方式实现在测试类中调用sayHello方法：<br><img src="https://img-blog.csdn.net/2018041516284377?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>这样，没有异议吧。<br>接下来使用spring调用该方法<br><img src="https://img-blog.csdn.net/20180415163216260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>结果为小强，是因为上面的配置文件中配置value为小强</p><p>这样一个基本的项目就完成了~<br><strong>接下来是细节：</strong></p><ul><li><p>创建User2这个类</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Bean;</span><br><span class="line">public class User2 &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayBye()&#123;</span><br><span class="line">        System.out.println(&quot;bye&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在User中新增<figure class="highlight plain"><figcaption><span>User2 user2;```并在sayHello中调用sayBye方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180415172500423?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line">- 执行test类报出错误，这是由于user2未注入</span><br><span class="line"> ![这里写图片描述](https://img-blog.csdn.net/20180415172825996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line">- 在配置文件中配置注入</span><br><span class="line"> ![这里写图片描述](https://img-blog.csdn.net/20180415172921661?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"> 注意点细节都已经在图中注释表明</span><br><span class="line">- 再次运行测试类</span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180415173307490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line">**spring运行原理图**</span><br><span class="line">![原理图](https://img-blog.csdn.net/20180415194047988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line">入门项目小结：</span><br><span class="line">**spring实际上是容器框架，可以配置各种bean，并可以维护bean与bean的关系，当我们需要使用某个bean的时候，我们可以直接getBean(id)，使用即可**</span><br><span class="line"></span><br><span class="line">现在我们来回答**什么是spring**这个问题</span><br><span class="line"> </span><br><span class="line"> - **spring是一个容器框架，它可以接管web层，业务层，dao层，持久层的各个组件，并且可以配置各种bean， 并可以维护bean与bean的关系，当我们需要使用某个bean的时候，我们可以直接getBean(id)，使用即可**</span><br><span class="line"></span><br><span class="line">**接下来对几个重要的概念做说明：**</span><br><span class="line"></span><br><span class="line">- **ioc是什么？**</span><br><span class="line">- ioc（inverse of control）控制反转：所谓反转就是把创建对象（bean）和维护对象（bean）的关系的权利从程序转移到spring的容器（spring-config.xml）</span><br><span class="line">- di是什么？</span><br><span class="line">- di（dependency injection）依赖注入：实际上di和ioc是同一个概念，spring的设计者，**认为di更准确的表示spring的核心**</span><br><span class="line"></span><br><span class="line">***实质上学习框架就是，最重要的就是学习各个配置***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#三、接口编程</span><br><span class="line"> - **spring就提倡接口编程，在配合di技术就可以达到层与层解耦的目的**</span><br><span class="line"> - 举案例说明：</span><br><span class="line">这个项目实现的是**大小写转换**</span><br><span class="line">  **基本思路：**</span><br><span class="line"> - 创建一个接口</span><br><span class="line"> - 创建两个类实现接口</span><br><span class="line"> - 配置bean</span><br><span class="line"> - 使用</span><br><span class="line"></span><br><span class="line">下面是我的项目目录</span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180416170338179?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line">**ChangeLetter.java**</span><br></pre></td></tr></table></figure></p></li></ul><p>package com.nuc;</p><p>public interface ChangeLetter {<br>    public String change();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**LowerLetter.java**</span><br></pre></td></tr></table></figure><p>package com.nuc;</p><p>public class LowerLetter implements ChangeLetter {<br>    private String str;</p><pre><code>public String getStr() {    return str;}public void setStr(String str) {    this.str = str;}public String change(){    //大小字母转小写    return str.toLowerCase();}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**UpperLetter.java**</span><br></pre></td></tr></table></figure><p>package com.nuc;</p><p>public class UpperLetter implements ChangeLetter {<br>    private String str;</p><pre><code>public String getStr() {    return str;}public void setStr(String str) {    this.str = str;}public String change(){    //把小写字母转成大写   return str.toUpperCase();}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**spring-config.xml**</span><br></pre></td></tr></table></figure><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd"><br>    <!--<bean id="changeLetter" class="com.nuc.UpperLetter">--><br>        <!--<property name="str">--><br>            <!--<value>sjt</value>--><br>        <!--</property>--><br>    <!--</bean>--></beans></p><pre><code>&lt;bean id=&quot;changeLetter&quot; class=&quot;com.nuc.LowerLetter&quot;&gt;    &lt;property name=&quot;str&quot; value=&quot;SJT&quot;/&gt;&lt;/bean&gt;</code></pre><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明：**其中的两个bean id名相同是为了调试方便，可通过注释来调试**</span><br><span class="line">**Test.java**</span><br></pre></td></tr></table></figure></p><p>package com.nuc;</p><p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p><p>public class Test {<br>    public static void main(String[] args) {<br>        ApplicationContext ac = new ClassPathXmlApplicationContext(“spring-config.xml”);<br>        //调用change不使用接口<br>//        UpperLetter changeLetter = (UpperLetter) ac.getBean(“changeLetter”);<br>//        System.out.println(changeLetter.change());</p><pre><code>    //使用接口    ChangeLetter changeLetter = (ChangeLetter)ac.getBean(&quot;changeLetter&quot;);    System.out.println(changeLetter.change());}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以上这个案例，我们可以初步体会到，di和接口编程，的确可以减少层（web层）和层（业务层）之间的耦合度，尽管**看起来似乎没什么改变，而且好像麻烦了一些，但是当项目大了以后，这种耦合度的降低就显得尤为重要**</span><br><span class="line"></span><br><span class="line">#四、获取Bean</span><br><span class="line">- **ApplicationContext 应用上下文容器取**</span><br><span class="line"></span><br><span class="line">```ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);</span><br></pre></td></tr></table></figure><pre><code>***当这句代码被执行，spring-config.xml文件中配置的bean就会被实例化。（但要注意bean的生命周期要为singleton），也就是说，不管没有getBean()，使用上下文容器获取bean，就会实例化该bean***</code></pre><ul><li><p><strong>Bean工厂容器取</strong></p>  <figure class="highlight plain"><figcaption><span>factory </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***这句代码被执行，spring-config.xml文件中配置的bean不会被实例化，即光实例化容器，并不会实例化bean***</span><br><span class="line">而是在执行以下代码时才会被实例化，**即使用bean的时候**：</span><br><span class="line">```factory.getBean(&quot;beanId&quot;);</span><br></pre></td></tr></table></figure><p>如何验证上述说法呢？每一个java类都有一个默认的构造方法。给这个构造方法输出一句话。<strong>具体如下</strong>：</p><ul><li>创建一个类，类有一个属性，装配，该属性</li><li>重写该类的构造方法，输出bean被创建</li><li>创建测试类，测试</li></ul><p><strong>使用ApplicationContext应用上下文容器</strong><br><img src="https://img-blog.csdn.net/20180416181257335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>使用bean工厂</strong><br><img src="https://img-blog.csdn.net/20180416181453917?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看到，这一行代码，并不能时bean实例化，接下来加factory.getBean(“student”);试试<br><img src="https://img-blog.csdn.net/20180416181738718?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>这样就是bean实例化了</p><p>那么在实际开发中选择哪种方式？</p><p><strong>在移动开发中，即项目运行在移动设备中使用BeanFactory（节约内存，所以，你想节约内存开发就是使用bean工厂，但速度会受影响），但大部分的项目都是使用ApplicationContext（可以提前加载，缺点是消耗一点内存）</strong><br>贴一张bean的生命周期图：<br><img src="https://img-blog.csdn.net/20180416183656148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>接下来我们验证前两种作用域：<br><strong>第一种</strong><br><img src="https://img-blog.csdn.net/20180416225235157?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>结果</strong><br><img src="https://img-blog.csdn.net/20180416225628432?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看到stu1和stu2拥有相同的地址，接下来测试第二种<br><img src="https://img-blog.csdn.net/20180416225719554?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180416225733267?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>测试结束！</strong><br>至于后三种是在web开发中才有实际意义！</p></li></ul><p>#五、三种获取ApplicationContext对象引用的方法</p><ul><li><strong>ClassPathXmlApplicationContext        （从类路径中加载）</strong><ul><li>这个不在赘述，上面所有例子都是利用这种方式加载的</li></ul></li><li><strong>FileSystemXmlApplicationContext       （从文件系统中加载）</strong><br>   <img src="https://img-blog.csdn.net/20180416231144330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  可以看到是没有问题的，需要注意的是，<strong>文件路径为绝对路径，且注意使用转义符，直接使用“C:\sjt\idea\code\spring\spring-interface\src”，会报错，需要将“\”转义</strong>，但实际开发中应用不多，了解即可</li><li><strong>XmlWebApplicationContext</strong>                 <strong>（从web系统中加载）</strong>  <ul><li>这种方式，注意，在tomcat启动时就会加载，此处不做说明，在web应用中说明</li></ul></li></ul><p>#六、再谈Bean的生命周期</p><ul><li><p><strong>生命周期是一个重点吗？答案是肯定的！！</strong></p><ul><li>不了解生命周期难道不能开发了吗？那自然是可以的，但如果你想实现更加高级的功能，你不了解那可能是会出问题的！而在面试过程中也是经常提及的。</li><li><p>接下里我们举例子说明</p><ul><li><p>生命周期分为以下几步：</p><ul><li><strong>1、实例化</strong><ul><li>当我们加载sping-config.xml文件时，bean就会被实例化到内存（前提是scope=singleton）</li></ul></li><li><strong>2、设置属性值</strong><ul><li>调用set方法设置属性，前提是有对应的set方法</li></ul></li><li><strong>3、如果你调用BeanNameAware的set’Bean’Name()方法</strong> <ul><li>这是个接口，该方法可以给出正在被调用的bean的id</li></ul></li><li><strong>4、如果你调用BeanFactoryAware的setBeanFactory()方法</strong><ul><li>这也是个接口，该方法可以传递beanFactory</li></ul></li><li><strong>5、如果你调用了ApplicationContextAeare的setApplicationContext()方法</strong><ul><li>同样为接口，该方法传递一个ApplicationContext</li></ul></li><li><strong>6、BeanPostProcessor的预初始化方法Before</strong><ul><li>这个东西很厉害了，可以叫做后置处理器，它不是接口，具体细节，代码体现</li></ul></li><li><strong>7、如果你调用了InitializingBean的afterPropertiesSet()方法</strong></li><li><strong>8、调用自己的init方法，具体为在bean中有一个属性inin-method=”init”</strong></li><li><strong>9、BeanPostProcessor的方法After</strong></li><li><strong>10、使用bean，体现为调用了sayHi()方法</strong></li><li><strong>11、容器关闭</strong></li><li><strong>12、可以实现DisposableBean接口的destory方法</strong></li><li><strong>13、可以在<bean destory-method="destory">调用自己的销毁方法，类似于8</bean></strong></li></ul><p><strong><em>实际开发过程中，并没有这么复杂，常见过程为，1，2，6，9，10，11</em></strong></p><p> <strong>接下来看代码</strong><br> <img src="https://img-blog.csdn.net/20180417165326682?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="目录结构"><br> <strong>MyBeanPostProcessor.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.BeanLife;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;第九步，postProcessAfterInitialization方法被调用&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;第六步，postProcessBeforeInitialization方法被调用&quot;);</span><br><span class="line">        System.out.println(&quot;第六步，&quot;+bean+&quot;被创建的时间为&quot;+new java.util.Date());</span><br><span class="line">        /*</span><br><span class="line">        在这里，能做的事情可就不止上面的这么简单的一句输出了，它还可以过滤每个对象的ip</span><br><span class="line">        还可以给所有对象添加属性或者函数，总之就是所有对象！</span><br><span class="line">        其实，这里体现了AOP编程的思想，AOP呢就是面向切成编程（针对所有对象编程）</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>PersonService.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.BeanLife;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.*;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class PersonService implements BeanNameAware,BeanFactoryAware,ApplicationContextAware,InitializingBean,DisposableBean&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        System.out.println(&quot;第二步调用set方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHi()&#123;</span><br><span class="line">        System.out.println(&quot;第十步，hi&quot;+ name);</span><br><span class="line">    &#125;</span><br><span class="line">    public PersonService()&#123;</span><br><span class="line">        System.out.println(&quot;第一步，实例化bean&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String arg0)&#123;</span><br><span class="line">        //该方法可以给出正在被调用的bean的id</span><br><span class="line">        System.out.println(&quot;第三步，setBeanName被调用，调用的id名为：&quot;+arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        //该方法可以传递beanFactory</span><br><span class="line">        System.out.println(&quot;第四步，setBeanFactory被调用，beanFactory为：&quot;+beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        //该方法传递一个ApplicationContext</span><br><span class="line">        System.out.println(&quot;第五步，调用setApplicationContext方法：&quot;+applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;第七步，调用afterPropertiesSet()方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;第八步、调用我自己的init()方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        //关闭数据连接，socket，文件流，释放资源</span><br><span class="line">        //这个函数的打印你看不到，应为</span><br><span class="line">        System.out.println(&quot;第十步，销毁方法（但不建议使用这种方式释放资源）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void destory()&#123;</span><br><span class="line">//        也看到不</span><br><span class="line">        System.out.println(&quot;销毁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Test.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.BeanLife;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);</span><br><span class="line">        PersonService person1= (PersonService) ac.getBean(&quot;personService&quot;);</span><br><span class="line">        person1.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>spring-config.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;personService&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; scope=&quot;singleton&quot; class=&quot;com.nuc.BeanLife.PersonService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;personService2&quot; class=&quot;com.nuc.BeanLife.PersonService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;sjt2&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!--配置自己的后置处理器，优点类似filter--&gt;</span><br><span class="line">    &lt;bean id=&quot;myBeanPostProcessor&quot; class=&quot;com.nuc.BeanLife.MyBeanPostProcessor&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><strong>测试结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">4月 17, 2018 4:57:26 下午 </span><br><span class="line">信息: Loading XML bean definitions from class path resource [spring-config.xml]</span><br><span class="line">第一步，实例化bean</span><br><span class="line">第二步调用set方法</span><br><span class="line">第三步，setBeanName被调用，调用的id名为：personService</span><br><span class="line">第四步，setBeanFactory被调用，beanFactory为：org.springframework.beans.factory.support.DefaultListableBeanFactory@ae13544: defining beans [personService,personService2,myBeanPostProcessor]; root of factory hierarchy</span><br><span class="line">第五步，调用setApplicationContext方法：org.springframework.context.support.ClassPathXmlApplicationContext@646d64ab: startup date [Tue Apr 17 16:57:26 CST 2018]; root of context hierarchy</span><br><span class="line">第六步，postProcessBeforeInitialization方法被调用</span><br><span class="line">第六步，com.nuc.BeanLife.PersonService@2e6a8155被创建的时间为Tue Apr 17 16:57:27 CST 2018</span><br><span class="line">第七步，调用afterPropertiesSet()方法</span><br><span class="line">第八步、调用我自己的init()方法</span><br><span class="line">第九步，postProcessAfterInitialization方法被调用</span><br><span class="line">第一步，实例化bean</span><br><span class="line">第二步调用set方法</span><br><span class="line">第三步，setBeanName被调用，调用的id名为：personService2</span><br><span class="line">第四步，setBeanFactory被调用，beanFactory为：org.springframework.beans.factory.support.DefaultListableBeanFactory@ae13544: defining beans [personService,personService2,myBeanPostProcessor]; root of factory hierarchy</span><br><span class="line">第五步，调用setApplicationContext方法：org.springframework.context.support.ClassPathXmlApplicationContext@646d64ab: startup date [Tue Apr 17 16:57:26 CST 2018]; root of context hierarchy</span><br><span class="line">第六步，postProcessBeforeInitialization方法被调用</span><br><span class="line">第六步，com.nuc.BeanLife.PersonService@6221a451被创建的时间为Tue Apr 17 16:57:27 CST 2018</span><br><span class="line">第七步，调用afterPropertiesSet()方法</span><br><span class="line">第九步，postProcessAfterInitialization方法被调用</span><br><span class="line">第十步，hisjt</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p><p><strong>动手做一遍是最好的选择！！</strong><br><strong>使用bean工厂获取bean对象，生命周期是和上下文获取的不一样的，如下图</strong><br><img src="https://img-blog.csdn.net/20180417172046494?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>其中我只装配了一个bean，可见执行步骤的短缺</p><p>#七、装配Bean</p><ul><li><p><strong>使用xml装配</strong></p><ul><li>上下文定义文件的根元素是<code>&lt;beans&gt;&lt;/beans&gt;</code>，有多个子元素<code>&lt;bean&gt;&lt;/bean&gt;</code>，每个<code>&lt;bean&gt;</code>元素定义了bean如何被装配到spring容器中</li><li>对子元素bean最基本的配置包括bean的ID和它的<strong>全称类名</strong></li><li>对bean的scope装配，默认情况下为单例模式，具体情况上面已经说过，建议查看文档，更加具体，<strong>尽量不要使用原型bean</strong>，即scope设置为propotype，这样子<strong>会对性能有较大的影响</strong></li><li><p>bean的<strong>init-metho</strong>和<strong>destory-method</strong>的书写，在生命周期那一块儿已经很清楚了，此处不再赘述，需要说明的是，<strong>可以通过注解的方式来配置，而不是在bean中使用init-metho和destory-method属性</strong><br>  <img src="https://img-blog.csdn.net/20180417174110574?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></li><li><p>注入集合类型的数据，例如，map，set，list，数组，Properties….</p><ul><li><p>接下来举例子<br><strong>目录结构：</strong><br><img src="https://img-blog.csdn.net/2018041816280517?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> </p><p> <strong>Department.java</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Department &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String []empName;//这里int的数组也可以注入成功</span><br><span class="line">    private List&lt;Employee&gt; empList;</span><br><span class="line">    private Map&lt;String,Employee&gt; empMap;</span><br><span class="line">    private Properties pp;</span><br><span class="line"></span><br><span class="line">    public Properties getPp() &#123;</span><br><span class="line">        return pp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPp(Properties pp) &#123;</span><br><span class="line">        this.pp = pp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;Employee&gt; getEmpSet() &#123;</span><br><span class="line">        return empSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmpSet(Set&lt;Employee&gt; empSet) &#123;</span><br><span class="line">        this.empSet = empSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Set&lt;Employee&gt; empSet;</span><br><span class="line">    public List&lt;Employee&gt; getEmpList() &#123;</span><br><span class="line">        return empList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmpList(List&lt;Employee&gt; empList) &#123;</span><br><span class="line">        this.empList = empList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getEmpName() &#123;</span><br><span class="line">        return empName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmpName(String[] empName) &#123;</span><br><span class="line">        this.empName = empName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Employee&gt; getEmpMap() &#123;</span><br><span class="line">        return empMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmpMap(Map&lt;String, Employee&gt; empMap) &#123;</span><br><span class="line">        this.empMap = empMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Employee.java</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc;</span><br><span class="line"></span><br><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Test.java</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);</span><br><span class="line">        Department department = (Department)ac.getBean(&quot;department&quot;);</span><br><span class="line">        System.out.println(department.getName());</span><br><span class="line">//        取集合</span><br><span class="line">        for(String empName:department.getEmpName())&#123;</span><br><span class="line">            System.out.println(empName);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;取list...&quot;);</span><br><span class="line">        for (Employee e:department.getEmpList())&#123;</span><br><span class="line">            System.out.println(&quot;name=&quot;+e.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;取set...&quot;);</span><br><span class="line">        for (Employee e:department.getEmpSet())&#123;</span><br><span class="line">            System.out.println(&quot;name=&quot;+e.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;迭代器取map...&quot;);</span><br><span class="line">        //1.迭代器</span><br><span class="line">        Map&lt;String,Employee&gt; employeeMap = department.getEmpMap();</span><br><span class="line">        Iterator iterator = employeeMap.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = (String)iterator.next();</span><br><span class="line">            Employee employee=employeeMap.get(key);</span><br><span class="line">            System.out.println(&quot;key=&quot;+key+&quot; &quot;+ employee.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;entry取map...&quot;);</span><br><span class="line">        //2.简洁(建议使用这种方式)</span><br><span class="line">        for (Entry&lt;String,Employee&gt; entry:department.getEmpMap().entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot; &quot;+entry.getValue().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;通过properties取数据&quot;);</span><br><span class="line">       Properties properties = department.getPp();</span><br><span class="line">       for (Entry&lt;Object,Object&gt; entry:properties.entrySet())&#123;</span><br><span class="line">           System.out.println(entry.getKey().toString()+&quot; &quot;+entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>spring-config.xml</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;department&quot; class=&quot;com.nuc.Department&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--给数组注入--&gt;</span><br><span class="line">        &lt;property name=&quot;empName&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;小明&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;小花&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--给list注入--&gt;</span><br><span class="line">        &lt;!--list可以存放相同的对象，并当作不同对象输出--&gt;</span><br><span class="line">        &lt;property name=&quot;empList&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;ref bean=&quot;employee1&quot;&gt;&lt;/ref&gt;</span><br><span class="line">                &lt;ref bean=&quot;employee2&quot;&gt;&lt;/ref&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--给set注入--&gt;</span><br><span class="line">        &lt;!--set集合不可以存放相同对象--&gt;</span><br><span class="line">        &lt;property name=&quot;empSet&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;ref bean=&quot;employee1&quot;&gt;&lt;/ref&gt;</span><br><span class="line">                &lt;ref bean=&quot;employee2&quot;&gt;&lt;/ref&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--给map注入--&gt;</span><br><span class="line">        &lt;!--输出的对象取决于key值，key值不同，对象相同也可以打出--&gt;</span><br><span class="line">        &lt;!--当key值相同时，对象相同或者不同都打出最后一个key所对应的对象--&gt;</span><br><span class="line">        &lt;property name=&quot;empMap&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;1&quot; value-ref=&quot;employee1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=&quot;2&quot; value-ref=&quot;employee2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=&quot;3&quot; value-ref=&quot;employee2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--给属性集合注入--&gt;</span><br><span class="line">        &lt;property name=&quot;pp&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;1&quot;&gt;hello&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;2&quot;&gt;world&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;employee1&quot; class=&quot;com.nuc.Employee&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;employee2&quot; class=&quot;com.nuc.Employee&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;太原&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p> 测试结果：<br> <img src="https://img-blog.csdn.net/20180418174234623?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><strong>注意点，细节都已在代码中注释！</strong></p></li></ul><ul><li>内部bean<ul><li>具体自行了解，实际中应用不多，不符合重用度高的原则</li></ul></li><li>继承配置bean<ul><li>举例说明：<br><strong>结构图：</strong><br><img src="https://img-blog.csdn.net/20180418171428284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>Student.java</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.inherit;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    protected String name;</span><br><span class="line">    protected int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><p><strong>Gradate.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.inherit;</span><br><span class="line"></span><br><span class="line">public class Gradate extends Student &#123;</span><br><span class="line">    private String degree;</span><br><span class="line"></span><br><span class="line">    public String getDegree() &#123;</span><br><span class="line">        return degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDegree(String degree) &#123;</span><br><span class="line">        this.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>spring-config.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置一个学生对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.nuc.inherit.Student&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!--配置gradate对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;gradate&quot; parent=&quot;student&quot; class=&quot;com.nuc.inherit.Gradate&quot;&gt;</span><br><span class="line">        &lt;!--如果子类重新赋值，则覆盖父类的--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;小明&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;degree&quot; value=&quot;博士&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Test2.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.inherit;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;com/nuc/inherit/spring-config.xml&quot;);</span><br><span class="line">        Gradate gradate = (Gradate) ac.getBean(&quot;gradate&quot;);</span><br><span class="line">        System.out.println(gradate.getName()+&quot; &quot;+gradate.getAge()+&quot; &quot;+gradate.getDegree());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>以上我们都是用set注入依赖的，下面介绍构造函数注入依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;user&quot; class=&quot;com.nuc.Bean.User&quot;&gt;</span><br><span class="line">    &lt;!--通过constructor-arg标签完成了对构造方法的传参--&gt;</span><br><span class="line">    &lt;!--如果是属性是类类型，则使用ref=&quot;&quot;--&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;小强&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;男&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;2&quot; type=&quot;int&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>当然对应的User要有相应的构造方法。<br><strong>set注入的缺点是无法清晰的表达哪个属性是必须的，哪些是可选的，构造器注入的优势，是可以通过构造强制依赖关系，不可能实例化不完全或者不能使用的bean</strong></p><p><strong><em>但其实实际开发中还是set注入较多，即property注入</em></strong></p><ul><li><strong>bean的自动装配：</strong><br>  <img src="https://img-blog.csdn.net/20180419155523787?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  接下来是实例：<br><strong>目录图</strong><br><img src="https://img-blog.csdn.net/20180419164128198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>Dog.java</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.autowire;</span><br><span class="line"></span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Master.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.autowire;</span><br><span class="line"></span><br><span class="line">public class Master &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Dog dog;</span><br><span class="line"></span><br><span class="line">    private Master(Dog dog)&#123;</span><br><span class="line">        //为了自动装配的constructor</span><br><span class="line">        this.dog= dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Dog getDog() &#123;</span><br><span class="line">        return dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDog(Dog dog) &#123;</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Test.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.autowire;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;com\\nuc\\autowire\\beans.xml&quot;);</span><br><span class="line">        Master master = (Master)ac.getBean(&quot;master&quot;);</span><br><span class="line">        System.out.println(master.getName()+&quot;养了只狗，它的名字叫&quot;+ master.getDog().getName()+&quot;，他今年&quot;+master.getDog().getAge()+&quot;岁了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>beans.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置master对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;master&quot; class=&quot;com.nuc.autowire.Master&quot; autowire=&quot;constructor&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--传统方式--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;dog&quot; ref=&quot;dog&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置dog对象，byName时使用--&gt;</span><br><span class="line">    &lt;!--&lt;bean id=&quot;dog&quot; class=&quot;com.nuc.autowire.Dog&quot;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;name&quot; value=&quot;小黄&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置dog对象，byType时使用--&gt;</span><br><span class="line">    &lt;!--&lt;bean id=&quot;dog11&quot; class=&quot;com.nuc.autowire.Dog&quot;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;name&quot; value=&quot;小黄&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置dog对象，constructor时使用--&gt;</span><br><span class="line">    &lt;bean id=&quot;dog22&quot; class=&quot;com.nuc.autowire.Dog&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;小黄&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><ul><li>autodetect:是在constructor和byType之间选一种</li><li><p>default：这种方式在文档中没有提及，需要在beans中指定，当你在beans中指定以后，所有的bean都是你所指定的装配方式，如果没有指定，则默认为no，<strong>所以，no之所以为默认指定装配方式，其实是从beans那里来的</strong><br><img src="https://img-blog.csdn.net/20180419165553430?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>其实在实际开发中，很少用到自动装配， 一般都是手动set装配的（property），而且自动装配也是在bean中没有配置才取执行自动装配的</strong></p><ul><li>spring本身提供的bean<ul><li>分散配置</li></ul></li></ul></li></ul><p>#八、AOP编程(难点)</p><ul><li><p>aop：aspect oriented programming（面向切面编程），它是对一类对象或所有对象编程。</p><ul><li>核心：<strong>在不增加代码的基础上，还增加新功能</strong></li><li>提醒：aop编程，实际上是开发框架本身用的多，开发中不是很多，将来会很多</li><li>初步理解：<strong>面向切面：其实是，把一些公共的“东西”拿出来，比如说，事务，安全，日志，这些方面，如果你用的到，你就引入。</strong></li></ul><p>接下来通过例子来理解这个抽象的概念,概念稍后再说</p><p><strong>步骤：</strong><br>拿前置通知打比方，后来还会有，后置通知，环绕通知，异常通知，引入通知</p><ul><li>定义接口</li><li>编写对象（被代理对象=目标对象）</li><li>编写通知（前置通知目标方法调用前调用）</li><li>在beans.xml中配置<ul><li>配置被代理对象</li><li>配置通知</li><li>配置代理对象（是proxyFactoryBean的对象实例）<ul><li>配置代理接口集</li><li>织入通知</li><li>配置被代理对象</li></ul></li></ul></li></ul><p>接下来看代码：<br><strong>目录结构：</strong><br><img src="https://img-blog.csdn.net/20180419205810780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>TestServiceInter.java(interface)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">public interface TestServiceInter &#123;</span><br><span class="line">    public void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>TestServiceInter2.java(interface)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">public interface TestServiceInter2 &#123;</span><br><span class="line">    public void sayBye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TestService.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">public class TestService implements TestServiceInter,TestServiceInter2&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;hi &quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayBye() &#123;</span><br><span class="line">        System.out.println(&quot;bye &quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MyMethodBeforeAdvice.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class MyMethodBeforeAdvice implements MethodBeforeAdvice &#123;</span><br><span class="line">    //前置通知</span><br><span class="line">    @Override</span><br><span class="line">    public void before(Method method, Object[] objects, Object o)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        //method：被调用方法的名字</span><br><span class="line">        //objects：给method传递的参数</span><br><span class="line">        //o：目标对象</span><br><span class="line">        System.out.println(&quot;记录日志。。。&quot;+method.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>beans.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置被代理的对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;testService&quot; class=&quot;com.nuc.Aop.TestService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!--配置前置通知--&gt;</span><br><span class="line">    &lt;bean id=&quot;myMethodBeforeAdvice&quot; class=&quot;com.nuc.Aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!--配置代理对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;proxyFactoryBean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!--配置代理接口--&gt;</span><br><span class="line">        &lt;property name=&quot;proxyInterfaces&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;com.nuc.Aop.TestServiceInter&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;com.nuc.Aop.TestServiceInter2&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--把通知织入到代理对象--&gt;</span><br><span class="line">        &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;!--相当于把myMethodBeforeAdvice前置通知和代理对象关联起来--&gt;</span><br><span class="line">            &lt;value&gt;myMethodBeforeAdvice&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--配置被代理对象,可以指定--&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;testService&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Test.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;com/nuc/Aop/beans.xml&quot;);</span><br><span class="line">        TestServiceInter testService = (TestServiceInter)ac.getBean(&quot;proxyFactoryBean&quot;);</span><br><span class="line">        testService.sayHello();</span><br><span class="line">        //当一个类继承多个接口，那么他们之间可以互转</span><br><span class="line">        ((TestServiceInter2)testService).sayBye();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>测试结果</strong><br><img src="https://img-blog.csdn.net/20180419210400217?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li><p><strong>AOP的术语</strong> </p><ul><li><strong>切面：</strong>要实现交叉功能，是系统模块化的一个切面领域，如记录日志</li><li><strong>连接点：</strong>应用程序执行过程中插入<strong>切面</strong>的地点，可以是方法调用，异常抛出，或者要修改的字段<ul><li>连接点是一个静态的概念</li></ul></li><li><strong>通知：</strong> <strong>切面</strong>的实际实现，它通知系统的新行为，如日志通知包含了实现日志功能的代码，如向日志文件写日志，通知在连接点插入应用系统中。</li><li><strong>切入点：</strong>定义了<strong>通知</strong>应该应用在哪些<strong>连接点</strong>，<strong>通知</strong>可以应用到AOP框架支持的任何<strong>连接点</strong><ul><li>切入点是动态概念，当通知应用了连接点，连接点就变成了切入点</li></ul></li><li><strong>引入：</strong>为类添加新方法和属性</li><li><strong>目标对象：</strong>被<strong>通知</strong>的对象，既可以是你编写的类，也可以是第三方类</li><li><strong>代理：</strong>将<strong>通知</strong>应用到目标对象后创建后的对象，应用系统的其他部分不用为了支持<strong>代理对象</strong>而改变<ul><li>spring的两种代理：<ul><li>若<strong>目标对象实现了若干个接口，spring使用JDK的java.lang.reflect.Proxy类代理</strong></li><li>若<strong>目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类</strong></li></ul></li></ul></li><li><p><strong>织入：</strong>将<strong>切面</strong>应用到<strong>目标对象</strong>从而创建一个新<strong>代理对象</strong>的过程，织入发生在<strong>目标对象</strong>生命周期的多个点上</p><ul><li><strong>编译期：</strong>切面在目标对象编译时织入，这需要一个特使的编译器</li><li><strong>类装载期：</strong>切面在目标对象被载入jvm时织入，这需要一个特殊的类加载器</li><li><strong>运行期：</strong>切面在应用系统运行时切入</li></ul><p>接下来引入<strong>后置通知，环绕通知，异常通知，引用通知</strong></p><p><strong><em>类似于前置通知，前三者需要继承一种接口，引用通知直接配置</em></strong></p></li></ul></li></ul><p><strong>MyAfterReturningAdvice.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class MyAfterReturningAdvice implements AfterReturningAdvice &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterReturning(Object o, Method method, Object[] objects,</span><br><span class="line">                               Object o1)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        //后置通知</span><br><span class="line">        //o：前面函数的返回值</span><br><span class="line">        //method：哪个方法被调用</span><br><span class="line">        //objects：调用方法的参数</span><br><span class="line">        //o1：目标对象</span><br><span class="line">        System.out.println(&quot;后置通知：调用结束，关闭资源。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MyMethodInterceptor.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line">public class MyMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">        //环绕通知</span><br><span class="line">        System.out.println(&quot;环绕通知：进入函数体，调用方法前&quot;);</span><br><span class="line">        Object obj = methodInvocation.proceed();</span><br><span class="line">        System.out.println(&quot;环绕通知：完成调用&quot;);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MyThrowsAdvice.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.Aop;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.ThrowsAdvice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class MyThrowsAdvice implements ThrowsAdvice &#123;</span><br><span class="line">    //异常通知</span><br><span class="line">    //ThrowsAdvice这个接口是标识性接口，没有任何方法</span><br><span class="line">   public void afterThrowing(Method m,Object[] os,Object target,Exception e)&#123;</span><br><span class="line">        System.out.println(&quot;异常通知：出问题了：&quot;+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>beans.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置被代理的对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;testService&quot; class=&quot;com.nuc.Aop.TestService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!--配置前置通知--&gt;</span><br><span class="line">    &lt;bean id=&quot;myMethodBeforeAdvice&quot; class=&quot;com.nuc.Aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!--配置后置通知--&gt;</span><br><span class="line">    &lt;bean id=&quot;myAfterReturningAdvice&quot; class=&quot;com.nuc.Aop.MyAfterReturningAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!--配置环绕通知--&gt;</span><br><span class="line">    &lt;bean id=&quot;myMethodInterceptor&quot; class=&quot;com.nuc.Aop.MyMethodInterceptor&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!--配置异常通知--&gt;</span><br><span class="line">    &lt;bean id=&quot;myThrowsAdvice&quot; class=&quot;com.nuc.Aop.MyThrowsAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!--定义前置通知的切入点（引用通知）--&gt;</span><br><span class="line">    &lt;bean id=&quot;myMethodBeforeAdviceFilter&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;advice&quot; ref=&quot;myMethodBeforeAdvice&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;mappedNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;!--这里支持使用正则表达式匹配--&gt;</span><br><span class="line">                &lt;!--配置了sayHello使用前置通知过滤--&gt;</span><br><span class="line">                &lt;value&gt;sayHello&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!--配置代理对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;proxyFactoryBean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!--配置代理接口--&gt;</span><br><span class="line">        &lt;property name=&quot;proxyInterfaces&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;com.nuc.Aop.TestServiceInter&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;com.nuc.Aop.TestServiceInter2&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--把通知织入到代理对象--&gt;</span><br><span class="line">        &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;!--相当于把myMethodBeforeAdvice前置通知和代理对象关联起来--&gt;</span><br><span class="line">                &lt;!--使用自定义切入点--&gt;</span><br><span class="line">                &lt;value&gt;myMethodBeforeAdviceFilter&lt;/value&gt;</span><br><span class="line">                &lt;!--织入后置通知--&gt;</span><br><span class="line">                &lt;value&gt;myAfterReturningAdvice&lt;/value&gt;</span><br><span class="line">                &lt;!--织入环绕通知--&gt;</span><br><span class="line">                &lt;value&gt;myMethodInterceptor&lt;/value&gt;</span><br><span class="line">                &lt;!--织入异常通知--&gt;</span><br><span class="line">                &lt;value&gt;myThrowsAdvice&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--配置被代理对象,可以指定--&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;testService&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><strong>TestService.java</strong><br><img src="https://img-blog.csdn.net/2018042016104749?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如图这一处变动<br>总之呢就是一个配置 -&gt; 织入的过程<br><strong>运行结果：</strong><br><img src="https://img-blog.csdn.net/20180420161255143?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>    可以看到前置通知和后置通知，<strong>似乎能够识别方法</strong>，事实上也是这样的（spring框架内置）。而且sayBay()也得到了应用。<strong>这正是，我们前面所提到了，AOP是对一类或所有对象编程的体现</strong>，又由于异常通知的配置，有了异常，由于引用通知的配置，致使sayBay的前置通知及后续无法通知。<br>    <strong>正常结果（配置引用通知）：</strong><br>    <img src="https://img-blog.csdn.net/20180420161721446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>#总结</p><p><strong><em>spring框架呢，其实就是学习了一大堆的配置，还有几个spring比较新颖的“思想”，IOC，AOP，这些技术。主要还是spring-config.xml文件的配置，之所以后来改成beans，是因为，这个文件就是对bean的配置！这套教程，是根据韩老师的视频总结的，全文基本都是要点，没有水货。。。（自我认为），因为韩老师将的很到位，很深刻，所以教程自然差不了</em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring常用注解🍂</title>
      <link href="/2018/04/04/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/04/04/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、引入注解的目的："><a href="#一、引入注解的目的：" class="headerlink" title="一、引入注解的目的："></a>一、引入注解的目的：</h1><ul><li>当bean过多时，会引起xml文件的过于臃肿，庞大，难以维护</li><li>加强java bean的内聚度</li></ul><h1 id="二、常用注解概述："><a href="#二、常用注解概述：" class="headerlink" title="二、常用注解概述："></a>二、常用注解概述：</h1><ul><li>@Service用于标注业务层组件、 </li><li>@Controller用于标注控制层组件（如struts中的action）</li><li>@Repository用于标注数据访问组件，即DAO组件。</li><li>@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</li><li><p>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：<br>@Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用</p></li><li><p>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</p></li></ul><hr><ul><li>@PreDestroy 摧毁注解 默认 单例  启动就加载</li><li>@Async异步方法调用</li><li>@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了 @Bean，就会作为这个Spring容器中的Bean。</li><li>@Scope用于指定scope作用域的（用在类上）</li><li>@PostConstruct用于指定初始化方法（用在方法上）</li><li>@PreDestory用于指定销毁方法（用在方法上）</li><li>@DependsOn：定义Bean初始化及销毁时的顺序</li><li>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</li><li>@Lazy(true) 表示延迟初始化</li></ul><p><strong>前面的更为常见！</strong></p><h1 id="三、详述"><a href="#三、详述" class="headerlink" title="三、详述"></a>三、详述</h1><p><strong>在使用注解前：要将使用注解的类都加载进xml中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot; &gt; </span><br><span class="line">&lt;!-- 这里使用base-package来引入这个包下的所有类--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.annotation&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h4 id="1、-Autowired"><a href="#1、-Autowired" class="headerlink" title="1、@Autowired"></a><strong>1、@Autowired</strong></h4><p>@Autowired顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的setter与bean属性中的property。</p><p>@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.annotation.dao.AnnotationDao;</span><br><span class="line">import com.annotation.service.AnnotationService;</span><br><span class="line">@Service</span><br><span class="line">@Scope(&quot;prototype&quot;)//这里的Scope和xml文件的用法一致</span><br><span class="line">public class AnnotationServiceImpl2 implements AnnotationService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private AnnotationDao ad;</span><br><span class="line">@Override</span><br><span class="line">public void p() &#123;</span><br><span class="line">System.out.println(&quot;Service注解测试2:&quot;+this.hashCode());</span><br><span class="line">ad.p();//加注解@Autowired就可以将dao注入到service中，同样在setter方法上，构造方法上，都可以注入成功，而不需要在xml中配置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，加上注解，这样在xml中就不用配置<code>&lt;bean&gt;&lt;/bean&gt;</code>了，同样在类上加这个注解也可以。</p><p><strong>假如：在xml中配置了bean而且有property（即没有注释的那种配置），但是，却没有setter方法，而给这个属性加了@Autowired，这样会成功吗？</strong><br>$\color{red}{答案是否定的，因为：Spring会按照xml优先的原则去相应的java文件中，}$<br>$\color{red}{寻找这两个属性的setter方法来配置}$</p><h4 id="2、-Scope"><a href="#2、-Scope" class="headerlink" title="2、@Scope"></a><strong>2、@Scope</strong></h4><p>如上：scope可以指定模式，默认还是singleton，即单例模式。”prototype”表示原型即每次都会new一个新的出来。</p><h4 id="3、-Service"><a href="#3、-Service" class="headerlink" title="3、@Service"></a><strong>3、@Service</strong></h4><p>@Service和@Controller、@Repository、@Component其实都是一样的，当你知道这个类具体是干什么的就用具体的注解，如果不知道就用@Component。（概述中已经叙述清楚）</p><p>另外：<strong>这里的@Service，干了两件事，1：声明该类是一个bean，这样才可以使用@Autowired来自动注入。2：这个类的bean的id是类名，且首字母小写</strong>，你也可以这样做，<code>@Service(&quot;这里你是想要的id名&quot;)</code></p><p>####<strong>4、@Autowired @Qualifier(“指定bean”)配套使用</strong><br>这种情况是：当出现一个接口有多个实现类时来区分使用，例如下面的<br>AnnotationService，这个接口就有两个实现类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.annotation;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import com.annotation.service.AnnotationService;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class QualifierResoutce &#123;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;annotationServiceImpl2&quot;)</span><br><span class="line">//@Resource(name=&quot;annotationServiceImpl2&quot;)</span><br><span class="line">public AnnotationService as;</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">public List&lt;AnnotationService&gt; list;</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">public Map&lt;String,AnnotationService&gt; map;</span><br><span class="line"></span><br><span class="line">public void p()&#123;</span><br><span class="line">System.out.println(&quot;QualifierResoutce&quot;);</span><br><span class="line">as.p();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print()&#123;</span><br><span class="line">System.out.println(&quot;-----list存放------&quot;);</span><br><span class="line">for(AnnotationService a:list)&#123;</span><br><span class="line">System.out.println(a.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;-----map存放------&quot;);</span><br><span class="line">for(Entry&lt;String, AnnotationService&gt; e:map.entrySet())&#123;</span><br><span class="line">System.out.println(e.getKey()+&quot;   &quot;+e.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的@Component，就是不知道这个类是干嘛的，所以就使用这个注解，</p><p>而这两个注解的配套使用就是，自动注入这个属性，并且走的是这个属性（接口）的哪个实现类</p><h4 id="5、-Resource"><a href="#5、-Resource" class="headerlink" title="5、@Resource"></a><strong>5、@Resource</strong></h4><p>上面也出现了这个注解，这个注解和@Autowired非常类似。</p><p><strong>@Resource的装配顺序：</strong><br>(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配<br>(2)、指定了name或者type则根据指定的类型去匹配bean<br>(3)、指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错</p><p><strong>@Resource和@Autowired的区别：</strong><br>(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配<br>(2)、@Autowired是Spring的注解，@Resource是J2EE的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了</p><p><strong>Spring属于第三方的，J2EE是Java自己的东西，因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。</strong></p><h4 id="6、-Controller"><a href="#6、-Controller" class="headerlink" title="6、@Controller"></a>6、@Controller</h4><p>@Controller对应表现层的Bean，也就是Action，当使用这个注解以后，spring容器中就会有一个和这个注解的类名相同（首字母小写）的action，</p><p>也可以这样@Controller(“ActionName”)来指定名字</p><p>同样@Repository，也是这样的</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring注入之属性、对象、集合、数组四种方式🍂</title>
      <link href="/2018/04/02/%E3%80%90Spring%E6%B3%A8%E5%85%A5%E3%80%91%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9B%86%E5%90%88%EF%BC%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2018/04/02/%E3%80%90Spring%E6%B3%A8%E5%85%A5%E3%80%91%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9B%86%E5%90%88%EF%BC%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、建一个spring空项目"><a href="#一、建一个spring空项目" class="headerlink" title="一、建一个spring空项目"></a>一、建一个spring空项目</h1><h1 id="二、新建student-java类"><a href="#二、新建student-java类" class="headerlink" title="二、新建student.java类"></a>二、新建student.java类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.printValue;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">private String age;</span><br><span class="line"></span><br><span class="line">public String getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(String age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void p()&#123;</span><br><span class="line">System.out.println(&quot;注入类&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;age:&quot;+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、新建SpringCollection-java类"><a href="#三、新建SpringCollection-java类" class="headerlink" title="三、新建SpringCollection.java类"></a>三、新建SpringCollection.java类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.printValue;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class SpringCollection &#123;//集合型的注入,对象的注入，数组的注入</span><br><span class="line">private String name;</span><br><span class="line">private List&lt;Object&gt; list;</span><br><span class="line">private Map&lt;String,String&gt; map;</span><br><span class="line">private Set&lt;String&gt; set;</span><br><span class="line">private Student student;</span><br><span class="line">private String[] strArr;//数组</span><br><span class="line"></span><br><span class="line">public SpringCollection(String name)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">System.out.println(&quot;constructor注入：&quot;+name);//构造器注入的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setList(List&lt;Object&gt; list) &#123;</span><br><span class="line">this.list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMap(Map&lt;String, String&gt; map) &#123;</span><br><span class="line">this.map = map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSet(Set&lt;String&gt; set) &#123;</span><br><span class="line">this.set = set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setStudent(Student student) &#123;</span><br><span class="line">this.student = student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setStrArr(String[] strArr) &#123;</span><br><span class="line">this.strArr = strArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print()&#123;</span><br><span class="line">System.out.println(&quot;property注入：&quot;+name);</span><br><span class="line">System.out.println(&quot;----list----&quot;);</span><br><span class="line">for(Object l:list)&#123;</span><br><span class="line">System.out.print(l+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(&quot;---set---&quot;);</span><br><span class="line">for(String s:set)&#123;</span><br><span class="line">System.out.print(s+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(&quot;---map---&quot;);</span><br><span class="line">for(Entry&lt;String, String&gt; entity:map.entrySet())&#123;</span><br><span class="line">System.out.print(entity.getKey()+&quot;:&quot;+entity.getValue()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(&quot;----注入类----&quot;);</span><br><span class="line">student.p();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(&quot;----注入数组----&quot;);</span><br><span class="line">for(String s1:strArr)&#123;</span><br><span class="line">System.out.print(s1+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、新建beans-xml文件。"><a href="#四、新建beans-xml文件。" class="headerlink" title="四、新建beans.xml文件。"></a>四、新建beans.xml文件。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; </span><br><span class="line">&lt;bean name=&quot;collection&quot; class=&quot;com.printValue.SpringCollection&quot;&gt;</span><br><span class="line">&lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;constructor&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;sjt&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;list&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;ref bean=&quot;stu&quot;/&gt;&lt;!--对象放到list中 --&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;set&quot;&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;map&quot;&gt;</span><br><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry key=&quot;1&quot; value=&quot;sjt1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key=&quot;2&quot; value=&quot;sjt2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key=&quot;1&quot; value=&quot;sjt11&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key=&quot;2&quot; value=&quot;sjt22&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;student&quot; ref=&quot;stu&quot; &gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;strArr&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;value&gt;3&lt;/value&gt;</span><br><span class="line">&lt;value&gt;4&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean name=&quot;stu&quot; class=&quot;com.printValue.Student&quot;&gt;</span><br><span class="line">&lt;property name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h1 id="五、新建测试类SpringCollectionTest-java"><a href="#五、新建测试类SpringCollectionTest-java" class="headerlink" title="五、新建测试类SpringCollectionTest.java"></a>五、新建测试类SpringCollectionTest.java</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import com.printValue.SpringCollection;</span><br><span class="line"></span><br><span class="line">public class SpringCollectionTest &#123;</span><br><span class="line">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans_collection.xml&quot;);</span><br><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">SpringCollection sc = (SpringCollection) ac.getBean(&quot;collection&quot;);</span><br><span class="line">sc.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、测试结果"><a href="#六、测试结果" class="headerlink" title="六、测试结果"></a>六、测试结果</h1><p><img src="https://img-blog.csdn.net/20180821155213951?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h1 id="七、注意事项："><a href="#七、注意事项：" class="headerlink" title="七、注意事项："></a>七、注意事项：</h1><ul><li><p>数组注入的时候，使用的也是list+value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;strArr&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;value&gt;3&lt;/value&gt;</span><br><span class="line">&lt;value&gt;4&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>对象注入的时候，是另外写一个bean，然后用引入到你想引入的bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;stu&quot; class=&quot;com.printValue.Student&quot;&gt;</span><br><span class="line">&lt;property name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>map输出的时候，是要用entry，并且map得调用entrySet方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(Entry&lt;String, String&gt; entity:map.entrySet())&#123;</span><br><span class="line">System.out.print(entity.getKey()+&quot;:&quot;+entity.getValue()+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接输出对象时，需要重写toString方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;age:&quot;+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础知识总结🍵</title>
      <link href="/2018/03/14/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/03/14/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Java起源"><a href="#1、Java起源" class="headerlink" title="1、Java起源"></a>1、Java起源</h3><ul><li>java Sun公司的，后期被甲骨文收购。</li><li>Java之父，詹姆斯高斯林， Java语言早起名字叫做：Oak，由C++演变而来；</li><li>Java 版本：jdk6 /7 最常用， 最新版本10；</li></ul><h3 id="2、Java三个平台："><a href="#2、Java三个平台：" class="headerlink" title="2、Java三个平台："></a>2、Java三个平台：</h3><ul><li>JavaSE（标准版，用于桌面应用开发）</li><li>JavaEE(企业版，用于企业级应用开发)</li><li>JavaME（微缩版，用于早期嵌入式开发）</li></ul><h3 id="3、JavaAPI"><a href="#3、JavaAPI" class="headerlink" title="3、JavaAPI"></a>3、JavaAPI</h3><ul><li>即Java应用程序接口</li><li><a href="https://pan.baidu.com/s/13oyAQHH1n8gF0HqXSW5WIg" target="_blank" rel="noopener">Java API 1.6手册下载</a></li><li><p>常用API</p><ul><li><p>StringBuffer和StringBuilder用法</p><ul><li>StringBuilder(线程不安全)/StringBuffer(线程安全)是可变长度字符串</li><li>使用append方法拼接字符串，效率高</li><li>默认有16位缓冲区</li><li>使用capacity方法获取真实长度，length方法获取字符个数； append方法拼接字符串；</li><li>$\color{red}{String 类型和StringBuffer的主要性能区别：}$<ul><li>String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。</li><li>使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。</li><li>在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer。<ul><li><strong>性能效率：StringBuilder&gt;StringBuffer&gt;String。</strong></li></ul></li></ul></li></ul></li><li><p>Math相关</p><ul><li>round(double d) 四舍五入取整返回long/int  </li><li>floor(double d) 向下取整返回double</li><li>ceil(double d) 向上取整返回double</li><li>abs(double/int )获取绝对值</li><li>random()获取0-1之间随机小数，非0和1</li></ul></li><li>Random随机数<ul><li>nextInt(int i)获取0-i之间的随机整数 </li><li>nextDouble()获取0-1之间随机小数，非0和1</li></ul></li><li>java.math.BigDecimal <ul><li>比double更精确的一种类型；常用于操作金额，汇率等；</li><li>常用方法：<ul><li>add</li><li>subtract</li><li>multiply </li><li>divide</li><li>setScale </li></ul></li></ul></li><li>SimpleDateFormat用法<ul><li>format(日期对象) 将日期格式化为指定格式字符串</li><li>parse(指定格式的日期字符串)将字符串转为Date 注意：格式必须跟SimpleDateFormat指定格式一致否则：<strong>ParseException</strong></li></ul></li><li>java.util.Date<ul><li>将1999-10-10格式字符串转为日期对象</li><li>new Date()获取当前系统时间</li><li>getTime()获取毫秒数</li></ul></li><li>java.sql.Date<ul><li>只用于获取系统当前时间</li></ul></li><li>Calendar<ul><li><strong>在Calendar类中，月份的值为实际的月份值减1</strong></li><li><strong>获得的星期的值和Date类不一样。在Calendar类中，周日是1，周一是2，周二是3，依次类推</strong></li></ul></li></ul></li></ul><h3 id="color-red-总之多查API"><a href="#color-red-总之多查API" class="headerlink" title="#$\color{red}{总之多查API}$"></a>#$\color{red}{总之多查API}$</h3><h3 id="4、Java语言的特性："><a href="#4、Java语言的特性：" class="headerlink" title="4、Java语言的特性："></a>4、Java语言的特性：</h3><ul><li>面向对象、</li><li>可移植性（一处编译，多处执行）、</li><li>跨平台性、</li><li>安全性(1、摒弃指针 2、GC垃圾回收机制：<strong>自动释放回收长时间不使用对象的内存</strong>)、<ul><li><a href="https://blog.csdn.net/canot/article/details/51037938" target="_blank" rel="noopener">点击深入了解GC</a></li></ul></li><li>并发性(支持多线程)、</li></ul><h3 id="5、JDK-amp-JRE"><a href="#5、JDK-amp-JRE" class="headerlink" title="5、JDK &amp;JRE"></a>5、JDK &amp;JRE</h3><ul><li><p>JDK(Java Development Kit   <strong>Java开发工具包</strong>)，JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。其中的开发工具：编译工具(javac.exe)  打包工具(jar.exe)、执行工具(java.exe)等</p></li><li><p>JRE(Java Runtime Environment    Java运行环境) ，包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p></li></ul><h3 id="6、配置环境变量（在任何位置都可以找到java环境）"><a href="#6、配置环境变量（在任何位置都可以找到java环境）" class="headerlink" title="6、配置环境变量（在任何位置都可以找到java环境）"></a>6、配置环境变量（在任何位置都可以找到java环境）</h3><ul><li>最简单配置方式：<ul><li>系统环境变量：<strong>PATH</strong>：C:\Program Files\Java\jdk1.7.0_13\bin; 后面保留</li><li><strong>CLASSPATH</strong>：C:\Program Files\Java\jdk1.7.0_13\lib;.后面保留</li></ul></li><li><p>或者：</p><ul><li>PATH: %JAVA_HOME%\bin;</li><li><p>CLASSPATH:%JAVA_HOME%\lib;.</p><p>也可以设置JAVA_HOME<br>JAVA_HOME :C:\Program Files\Java\jdk1.7.0_13</p></li></ul><p>验证是否配置成功： 进入命令行窗口， 执行<strong>java -version</strong>，成功显示版本号即成功配置</p></li></ul><h3 id="7、开发工具："><a href="#7、开发工具：" class="headerlink" title="7、开发工具："></a>7、开发工具：</h3><ul><li>Eclipse </li><li>MyEclipse </li><li>IntelliJ IDEA </li></ul><h3 id="8、Java程序的执行过程"><a href="#8、Java程序的执行过程" class="headerlink" title="8、Java程序的执行过程"></a>8、Java程序的执行过程</h3><ul><li>java源文件，编译器(javac命令)进行编译</li><li>生成class文件(存放的字节码)</li><li>然后解析器（执行java命令）解析class文件</li><li>最后生成计算机识别的二进制编码</li></ul><h3 id="9、Java有两种数据类型："><a href="#9、Java有两种数据类型：" class="headerlink" title="9、Java有两种数据类型："></a>9、Java有两种数据类型：</h3><ul><li>1、<strong>引用数据类型：</strong>数组、类、接口。</li><li>2、<strong>基本数据类型：</strong><ul><li>整型：byte、short、int、long （8位1个字节、16/2 、32/4、64/8）</li><li>浮点型：float、double(32/4 、64/8)</li><li>字符型：char(16/2)</li><li>布尔类型：boolean</li></ul></li><li><strong>级别从低到高为：</strong> byte,char,short(这三个平级)–&gt;int–&gt;float–&gt;long–&gt;double</li><li><strong>自动类型转换：</strong>从低级别到高级别，系统自动转的；</li><li><p><strong>强制类型转换：</strong>什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；</p><p><strong>Java中默认整数为int类型， 小数为double类型；</strong><br><strong>字符char是否可以存放一个汉字？可以，因为一个字符占2个字节，一个汉字两个字节；</strong><br><strong>整型初始值默认0  浮点型默认0.0 布尔类型默认false 引用数据类型默认null</strong></p></li></ul><h3 id="10、java中是否有goto？-有，是保留字"><a href="#10、java中是否有goto？-有，是保留字" class="headerlink" title="10、java中是否有goto？ 有，是保留字"></a>10、java中是否有goto？ 有，是保留字</h3><h3 id="11、标识符命名规则："><a href="#11、标识符命名规则：" class="headerlink" title="11、标识符命名规则："></a>11、标识符命名规则：</h3><ul><li>可以由数字、字母、下划线、$符号组成，但是不能是关键词，不能以数字开头</li><li><strong>全局变量(成员变量、类变量)</strong><ul><li>可以供当前类的多个方法使用；</li><li>定义在类中；</li><li>成员变量存在于<strong>堆内存中</strong>，随着对象的产生而存在，消失而消失。</li></ul></li><li><strong>局部变量</strong><ul><li>定义在方法中或者方法参数</li><li>只能作用于当前方法</li><li>没有初始值</li><li>局部变量存在于<strong>栈内存中</strong>，随着所属区域的运行而存在，结束而释放。</li></ul></li><li><strong>常量：</strong> 只能声明在类中，使用final关键词声明，必须赋初始值，不能再次赋值；</li></ul><h3 id="12、Java中数据类型转换："><a href="#12、Java中数据类型转换：" class="headerlink" title="12、Java中数据类型转换："></a>12、Java中数据类型转换：</h3><ul><li><strong>隐式转换：</strong>系统默认将其转换为我们需要的数据类型；</li><li><p><strong>强制转换：</strong>=号两边数据类型不同时，可以通过,前面加(类型)转换 </p><ul><li>例如：int j=10;float f=100.123; int j=(int)f;</li></ul></li><li><p><strong>基本数据类型之间规则：</strong></p><ul><li>(1)整型之间数据类型强制转换规则：long-&gt;int-&gt;short-&gt;byte <ul><li>(2)浮点型之间：double-&gt;float <ul><li>(3)char和整型 :   整型-&gt;char </li></ul></li></ul></li><li>(4)char和浮点型:  浮点型-&gt;char</li><li>(5)浮点型和整型 :  (double/float)-&gt;(long/int/short/byte) 且小数点舍去</li></ul></li></ul><h3 id="13、运算符："><a href="#13、运算符：" class="headerlink" title="13、运算符："></a>13、运算符：</h3><ul><li>+</li><li>-</li><li>*</li><li>/ </li><li>%<ul><li><strong>任何整数模2不是0就是1，</strong>所以只要改变被模数就可以实现开关运算。</li></ul></li><li>位运算符:用于操作二进制位的运算符。<ul><li>&amp;  |  ^ &lt;&lt;  &gt;&gt;   &gt;&gt;&gt;(无符号右移)</li></ul></li><li><p>注意：</p><ul><li>(1)+号拼字符串：”字符串”+数字+数字 和”字符串”+(数字+数字)</li><li>(2)分母不可以为0 否则报异常：<strong>ArithmeticException</strong></li><li>(3)java中数值运算时，位数多的与位数少的，做运算，最终结果类型为位数多的（long+double 返回double） 整型和浮点型运算，此时返回浮点型</li><li>(4)$\color{red}{java中1/2值为多少？0}$</li><li>(5)$\color{red}{2的三次幂如何计算？ 2&lt;&lt;2;}$</li></ul></li><li><p>i++ 表示i先参与运算，然后在自身加1 </p></li><li>++i 表示i先自身加1 然后在被使用</li><li><p>类似的 - -运算也是一样的</p><p>$\color{red}{注意!}$下面程序是否有错？<br><code>short i=10；i=i+1;(错误，因为需要强转 short+int结果还是int类型)i+=1;（正确）</code></p></li><li><p>逻辑运算符（也叫作短路运算符）：</p><ul><li>||<ul><li>或，两边条件有一个满足true，则结果为true </li></ul></li><li><p>&amp;&amp;</p><ul><li>与， &amp;&amp;两边条件必须返回boolean类型，两边同时为true则结果为true</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n=10;</span><br><span class="line">int m=100;</span><br><span class="line">boolean f_2=(n&gt;m)&amp;&amp;((n=100000)&lt;100); </span><br><span class="line">System.out.println(n);//n的值还是10</span><br><span class="line">boolean f_3=(m&gt;n)||((n=100000)&lt;100); //n的值还是10</span><br></pre></td></tr></table></figure><p><strong>下表为优先级顺序，优先级高的在上部，同一行优先级相同</strong><br><strong>第三行中的“+”“-”为正负的含义</strong><br><img src="https://img-blog.csdn.net/2018081615364613?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></li></ul></li></ul><h3 id="14、判断语句-amp-循环语句break-amp-continue"><a href="#14、判断语句-amp-循环语句break-amp-continue" class="headerlink" title="14、判断语句&amp;循环语句break&amp;continue"></a>14、判断语句&amp;循环语句break&amp;continue</h3><ul><li><p>判断语句</p><ul><li><code>if(条件){}</code></li><li>switch选择判断语句<a href="https://blog.csdn.net/qq_38341596/article/details/78629070" target="_blank" rel="noopener">点击查看更多</a></li></ul></li><li><p>循环语句    </p><ul><li><code>for(;条件;){循环体}</code></li><li><code>while(){}</code></li><li><code>do{}while()</code></li></ul></li><li>break 表示退出整个循环或者判断</li><li>continue 只能用于循环体中，表示退出当前循环，继续下一次循环</li></ul><h3 id="15、Java的核心包：即java-lang包"><a href="#15、Java的核心包：即java-lang包" class="headerlink" title="15、Java的核心包：即java.lang包"></a>15、Java的核心包：即java.lang包</h3><h3 id="16、包装类：即基本数据类型所对应的类；"><a href="#16、包装类：即基本数据类型所对应的类；" class="headerlink" title="16、包装类：即基本数据类型所对应的类；"></a>16、包装类：即基本数据类型所对应的类；</h3><ul><li>int/double/float/byte/long/char/boolean 是一种值表示；</li><li><p>Integer/Double/Float/Byte/Long/Character/Boolean 包装类</p></li><li><p>常用方法：</p><ul><li>valueOf(“”)</li><li>valueOf(int i) </li><li>toString（）</li><li>parseInt(“”);</li><li>$\color{red}{注意异常!}$ NumberFormatException</li></ul></li></ul><h3 id="17、-比较和equals比较"><a href="#17、-比较和equals比较" class="headerlink" title="17、==比较和equals比较"></a>17、==比较和equals比较</h3><ul><li>==比较即比较内容也比较地址是否相同；</li><li><p>equals方法，比较两个对象内容是否相同</p><p><strong>注意：</strong></p><ul><li>（1）字符串比较，不允许用== ，只能通过equals方法</li><li><p>（2）如果Integer和Integer/int比较具体是否相等，此时绝对不允许使用== </p><ul><li><strong>补充：127 128 问题：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 127;</span><br><span class="line">Integer b = 127;</span><br><span class="line">System.out.println(a==b);true</span><br><span class="line">//超一个字节会重新分配空间</span><br><span class="line">Integer c = 128;</span><br><span class="line">Integer d = 128;</span><br><span class="line">System.out.println(c==d);false</span><br></pre></td></tr></table></figure></li></ul></li><li><p>（3）注意：数字，和字符串比较是否相等；</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;10&quot;;</span><br><span class="line">Integer m=10;</span><br><span class="line">System.out.println(m.equals(str));//false</span><br><span class="line">System.out.println(m.toString().equals(str));//true</span><br></pre></td></tr></table></figure><p> <a href="https://blog.csdn.net/Song_JiangTao/article/details/82023526" target="_blank" rel="noopener">更多详情点击查看第5点</a></p><h3 id="18、数组："><a href="#18、数组：" class="headerlink" title="18、数组："></a>18、数组：</h3></li><li>先定义、开辟空间、赋值在使用</li><li>java中数组长度不可变</li><li>数组下标从0开始</li><li><p><strong>数组的定义：</strong></p><ul><li>（1） <code>String[] items_0=null;//先定义 items_0=new String[4];//开辟空间</code></li><li>（2）<code>String[] items_1=new String[4];</code></li><li>（3）<code>String[] items_2={&quot;JONES&quot;,&quot;SMITH&quot;,&quot;XIAOMING&quot;,&quot;SMI&quot;};</code></li><li>（4） <code>String[] items_3=new String[]{&quot;SMITH&quot;,&quot;JINES&quot;,&quot;DSFDSF&quot;};</code></li></ul><p>$\color{red}{如何不通过第三个变量交换两个变量的值？}$ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line">a=a+b;//a:30 b:20</span><br><span class="line">b=a-b;//a:30 b:10</span><br><span class="line">a=a-b;//a:20 b:10</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>二维数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[][] items=new String[2][3];</span><br><span class="line">//items[0]=&#123;&quot;&quot;,&quot;&quot;,&quot;&quot;&#125;;错误的</span><br><span class="line">// items[0]=new String[4];对</span><br></pre></td></tr></table></figure></li><li><p>数组的复制    </p><ul><li><code>System.arraycopy(strArr,0, strArr1, 0, 3);//从左到右参数意义：从哪个数组，从哪开始复制，复制到哪？开始位置，复制多长</code></li><li><code>System.out.println(&quot;copyOf复制：&quot;+Arrays.toString(Arrays.copyOf(strArr, 3)));</code></li></ul></li><li>数组的排序<ul><li><code>Arrays.sort(strArr1);</code></li></ul></li></ul><h3 id="19、类：是一类事物的描述，程序中为class；"><a href="#19、类：是一类事物的描述，程序中为class；" class="headerlink" title="19、类：是一类事物的描述，程序中为class；"></a>19、类：是一类事物的描述，程序中为class；</h3><ul><li>属性：即一类事物具有的共有特点或者特性；程序中为全局变量（成员变量)</li><li>方法：一类事物具有的动作； </li><li>类的定义和使用<ul><li>class 类名称{<br> 属性<br> 方法<br>}</li><li>使用关键字new就可以创建类对象，使用<strong>对象.方法，对象.属性</strong>就可完成调用</li><li>$\color{red}{创建一个对象都在内存中做了什么事情？}$<ul><li>1：先将硬盘上指定位置的Person.class文件加载进内存。</li><li>2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。</li><li>3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new</li><li>4：在该实体空间中进行属性的空间分配，并进行了默认初始化。</li><li>5：对空间中的属性进行显示初始化。</li><li>6：进行实体的构造代码块初始化。</li><li>7：调用该实体对应的构造方法，进行构造方法初始化。（）</li><li>8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)</li></ul></li></ul></li></ul><ul><li>抽象类: <strong>abstract</strong><ul><li>抽象类的特点：<ul><li>1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。</li><li>2：抽象方法只定义方法声明，并不定义方法实现。非抽象的方法可以定义方法实现</li><li>3：抽象类不可以被创建对象(实例化)。</li><li>4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</li></ul></li><li>抽象类的细节：<ul><li>1：抽象类中是否有构造方法？有，用于给子类对象进行初始化。</li><li>2：抽象类中是否可以定义非抽象方法？可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。<strong>只不过，比一般类多了一个抽象方法。而且比一般类少了一个创建对象的部分。</strong></li><li>3：抽象关键字abstract和哪些不可以共存？final ,private , static</li><li>4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。</li><li>5：抽象类中可以有普通的成员变量</li><li>6：抽象类中可以有静态方法</li></ul></li></ul></li><li>接口：<strong>interface</strong><ul><li>接口的特点：<ul><li>1、接口<strong>是特殊抽象类</strong>，所有方法都是抽象方法，都是<strong>public访问权限</strong>，数据成员都是<strong>public，static，final</strong></li><li>2、<strong>不能被实例化</strong>，方法abstract关键词可以省略，但实际上还是抽象方法</li><li>3、<strong>变量都是是常量</strong>，省略final关键词；</li><li>4、接口不能被实例化，只能通过<strong>implements</strong>来实现接口，一个实现类，可以实现多个接口</li><li>5、接口可以继承接口。</li><li>6、实现以后要重写<strong>所有</strong>抽象方法，包括接口继承接口中的抽象方法</li><li>7、接口中不能有构造方法</li></ul></li><li>接口的好处：<ul><li>1、java由于单继承，接口可以<strong>弥补无法多继承的缺点</strong></li><li>2、好的程序要求高内聚低耦合，接口可以实现程序的<strong>解耦</strong></li><li>3、定义一种<strong>规范</strong></li></ul></li></ul></li><li><p><strong>抽象类和接口的区别</strong>：</p><ul><li>抽象类只能被继承，而且只能单继承。</li><li>接口需要被实现，而且可以多实现。<br><br></li><li>抽象类中可以定义非抽象方法，子类可以直接继承使用。</li><li>接口中都有抽象方法，需要子类去实现。<br><br></li><li>抽象类使用的是  is a 关系。</li><li>接口使用的 like a 关系。<br><br></li><li>抽象类的成员修饰符可以自定义。</li><li>接口中的成员修饰符是固定的。全都是public的。<br><br>    </li><li>抽象类可以有构造方法，接口中不能有构造方法<br><br>    </li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li></ul></li><li><p>面向对象：<strong>面向对象是一种思想，是基于面向过程而言的</strong>，面向对象即分析某一个事件中有哪些对象，分析他们的动作，具有的属性特点，通过这种方式来解决问题；  </p></li><li>面向过程： 侧重点在于步骤，通过一步一步调用方法来实现操作</li></ul><p><a href="https://blog.csdn.net/Song_JiangTao/article/details/82023526" target="_blank" rel="noopener">面向对象的问题详情请点击查看第1点！</a></p><ul><li>对象实例化： new 类（），即对象的创建；</li></ul><h3 id="20、static"><a href="#20、static" class="headerlink" title="20、static"></a>20、static</h3><ul><li>static 声明方法为静态方法，声明属性为静态属性；</li><li>static 关键词：<ul><li>1、static 修饰方法，该方法叫做静态方法（也叫做类方法），可直接通过这个类的类名打点直接调用；</li><li>2、静态方法中不能使用<strong>this/super</strong>关键词，静态方法不能直接调用当前类中的非静态方法（或非静态属性），必须通过new实例化后在调用。</li><li>3、static声明的方法和属性，该对象已经被实例化，且<strong>只能被实例化一次(单例模式)</strong></li><li>4、<strong>static修饰的属性，被相同类的不同实例所共享</strong>；</li></ul></li></ul><h3 id="21、this"><a href="#21、this" class="headerlink" title="21、this"></a>21、this</h3><ul><li>$\color{red}{表示当前类对象，}$<strong>不能用于static声明的方法中，</strong> 常用于区分全局变量和局部变量同名</li></ul><h3 id="22、super"><a href="#22、super" class="headerlink" title="22、super"></a>22、super</h3><ul><li>（1）使用super关键字,$\color{red}{super代表父类对象 }$，<strong>只能用在子类中</strong></li><li>（2）可在子类构造方法中调用且<strong>必须是该方法中第一句</strong></li><li>（3）不能使用在static修饰的方法中</li><li>（4）super的用处<ul><li>访问父类构造方法<ul><li><code>super();</code></li><li><code>super(name);</code></li></ul></li><li>访问父类属性<ul><li><code>super.name;</code></li></ul></li><li>访问父类方法<ul><li><code>super.print();</code></li></ul></li></ul></li></ul><h3 id="23、final"><a href="#23、final" class="headerlink" title="23、final"></a>23、final</h3><ul><li><p>1.修饰类</p><p>  当用final修饰一个类时，<strong>表明这个类不能被继承</strong>。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p><p>  在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。</p></li><li><p>2.修饰方法</p><p>  下面这段话摘自《Java编程思想》第四版第143页：</p><blockquote><p>使用final方法的原因有两个。<strong>第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。</strong>在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</p></blockquote></li></ul><p>　　<strong>因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。</strong></p><p>　　$\color{blue}{注：类的private方法会隐式地被指定为final方法。}$</p><ul><li><p>3.修饰变量     </p><p>  对于一个final变量，如果是基本数据类型的变量，则其<strong>数值一旦在初始化之后便不能更改</strong>；如果是引用类型的变量，则在对其<strong>初始化之后便不能再让其指向另一个对象</strong>。</p><p>  更多细节访问<a href="https://www.cnblogs.com/dolphin0520/p/3736238.html" target="_blank" rel="noopener">点击这里</a></p></li></ul><h3 id="24、访问修饰符："><a href="#24、访问修饰符：" class="headerlink" title="24、访问修饰符："></a>24、访问修饰符：</h3><p> <img src="https://img-blog.csdn.net/20180610165012739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="25、面向对象三个过程："><a href="#25、面向对象三个过程：" class="headerlink" title="25、面向对象三个过程："></a>25、面向对象三个过程：</h3><ul><li>OOA面向对象分析 </li><li>OOD面向对象设计</li><li>OOP面向对象编程</li></ul><h3 id="26、面向对象三个特性-属性"><a href="#26、面向对象三个特性-属性" class="headerlink" title="26、面向对象三个特性(属性)"></a>26、面向对象三个特性(属性)</h3><ul><li><strong>继承</strong><ul><li>继承就是类之间的继承，使用extends来实现，从而实现代码的复用</li></ul></li><li><strong>多态</strong><ul><li>某一种事物有不同的具体的体现就是<strong>多态</strong>。</li><li>多态<strong>体现</strong>在：重写、重载、对象实例化。</li><li>多态的<strong>好处</strong>：提高了程序的扩展性。</li><li>多态的<strong>弊端</strong>：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)</li></ul></li><li><strong>封装</strong><ul><li><strong>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</strong></li><li>好处：将变化隔离；便于使用；提高重用性；安全性。</li><li>封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。</li></ul></li></ul><h3 id="27、构造方法"><a href="#27、构造方法" class="headerlink" title="27、构造方法"></a>27、构造方法</h3><ul><li><strong>该方法与类名相同；没有返回值也不可以使用void 声明</strong></li><li>默认public修饰</li><li>任何一个类，都有一个无参数的构造方法； 对象实例化时被执行</li><li><strong>构造方法和普通方法的区别</strong><ul><li>构造方法是在对象创建时，就被调用，构造方法常用于初始化成员变量，而且初始化动作只执行一次。</li><li>一般方法，是对象创建后，需要调用才执行，可以被调用多次。</li></ul></li></ul><h3 id="28、-程序的执行过程"><a href="#28、-程序的执行过程" class="headerlink" title="28、 程序的执行过程"></a>28、 程序的执行过程</h3><ul><li><p>单一类中： </p><ul><li>1.初始化块2. 静态初始化块3.构造方法</li><li><strong>执行顺序：</strong>静态初始化块（永远只被执行一次） 初始化块 构造方法</li></ul></li><li><p>父类和子类中都有静态代码块，非静态代码块，构造方法时。</p><ul><li>初始化子类对象时，<strong>调用顺序：</strong>父类静态，子类静态，父类非静态，父类构造，子类非静态，子类构造</li></ul></li><li><p><strong>静态域</strong></p><ul><li>其实最先初始化的并不是静态块，而是静态域，而静态域中包含静态变量、静态块和静态方法，其中需要初始化的是静态变量和静态块。而他们两个的初始化顺序是靠他们俩的位置决定的!</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class B</span><br><span class="line">&#123;</span><br><span class="line">    public static B t1 = new B();</span><br><span class="line">    public static B t2 = new B();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;构造块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;静态块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        B t = new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：构造块 构造块 静态块 构造块</strong></p></li></ul><h3 id="29、方法重载：overload"><a href="#29、方法重载：overload" class="headerlink" title="29、方法重载：overload"></a>29、方法重载：overload</h3><ul><li><strong>当前类中方法名相同，参数个数或者参数类型不同；</strong> </li><li><p>public String student(String name,int age){…….}<br>public void student(int age,String name){………}<br>这个也是重载</p></li><li><p>为什么重载，重载有什么好处？</p><ul><li>了解：好处便于记忆筛选，体现了java的多态</li></ul></li></ul><h3 id="30、方法重写：override"><a href="#30、方法重写：override" class="headerlink" title="30、方法重写：override"></a>30、方法重写：override</h3><ul><li><strong>发生在子类中，子类的方法与父类方法名、参数个数、参数类型，返回值类型完全相同，并且访问权限不能严于父类</strong></li><li>什么时候使用重写？<ul><li>1、当父类方法无法满足子类需求，此时可以在子类中重写父类方法</li><li>2、如果开发时，需要对父类方法功能拓展，此时还不想修改父类程序<br>则使用继承(定义一个类继承父类)，然后通过子类重写该方法，<br>然后其他类进行调用这个子类方法； </li></ul></li></ul><h3 id="31、继承："><a href="#31、继承：" class="headerlink" title="31、继承："></a>31、继承：</h3><ul><li>子类继承父类，可以继承父类中<strong>非私有的方法和属性</strong>；</li><li>构造方法无法被继承；</li><li>final修饰的类无法被继承；</li><li>Java中是单继承，<strong>所有类的超类（父类/基类）是java.lang.Object类</strong></li><li>$\color{red}{如果一个类既继承了一个类又实现了接口，那么次序是，先继承，后实现！！}$</li><li><p>子类被实例化时，先实例化父类对象</p><ul><li><p>java中是单继承，即一个类只能有一个父类；所有类的父类（超类）是java.lang.Object</p><ul><li><p>继承的好处：</p><ul><li>1、简化子类代码</li><li>2、使用继承可以不修改父类程序前提，完成对父类方法的拓展</li></ul></li><li><p>缺点：</p></li><li>1、打破了封装（封装的目的是隐藏），父类向子类暴露了细节</li><li>2、过多的继承，会导致程序不便于维护</li><li>3、白盒重用，因为基类的内部细节通常对子类是可见的</li></ul></li></ul></li></ul><h3 id="32、所有类的父类Object类"><a href="#32、所有类的父类Object类" class="headerlink" title="32、所有类的父类Object类"></a>32、所有类的父类Object类</h3><ul><li>Object位于java.lang包下面</li><li>其中常用的方法有：<ul><li><strong>toString();</strong> 返回当前对象本身的有关信息，按字符串对象返回</li><li><strong>equals();</strong> 比较两个对象是否是同一个对象，是则返回true</li><li>hashCode(); 返回该对象的哈希代码值</li><li>getClass(); 获取当前对象所属的类信息，返回Class对象</li></ul></li><li>equals方法的重写：<ul><li>什么时候重写equals方法？<ul><li>比较两个对象时候，需要重写equals方法，重新定义比较规则</li></ul></li></ul></li><li>toString方法重写：<ul><li>重写toString方法的目的是：让对象以某个字符串形式表示</li></ul></li></ul><h3 id="33、主方法的分析"><a href="#33、主方法的分析" class="headerlink" title="33、主方法的分析"></a>33、主方法的分析</h3><ul><li><code>public static void main(String[] args){}</code></li><li><p>1）保证该类的独立运行。</p></li><li><p>2）它是程序的入口。</p></li><li><p>3）它被jvm调用。</p><ul><li><p>Public：访问权限最大。</p></li><li><p>static：不需要对象，直接类名即可。</p></li><li><p>void：主方法没有返回值。</p></li><li><p>main：主方法特定的名称。</p></li><li><p>(String[] args)：主方法的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。</p><p><strong>注意：主方法的存在，仅为该类是否需要独立运行，如果不需要，主方法是不用定义的。</strong></p></li></ul></li></ul><h3 id="34、Java内存的总结"><a href="#34、Java内存的总结" class="headerlink" title="34、Java内存的总结"></a>34、Java内存的总结</h3><ul><li><p>java分了5片内存</p><ul><li>1：寄存器。</li><li>2：本地方法区。</li><li>3：方法区。</li><li>4：栈。</li><li>5：堆。</li></ul></li><li><p>栈：存储的都是局部变量 ( 方法中定义的变量，方法上的参数，语句中的变量 )；<strong>只要数据运算完成所在的区域结束，该数据就会被释放。</strong></p></li><li><p>堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。</p><pre><code>- 1：每一个实体都有内存首地址值- 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。- 3：垃圾回收机制。    </code></pre><h3 id="35、自动装箱，自动拆箱"><a href="#35、自动装箱，自动拆箱" class="headerlink" title="35、自动装箱，自动拆箱"></a>35、自动装箱，自动拆箱</h3></li><li>Java有8种基本类型，每种基本类型又有对应的包装类型。在Java中，一切都以对象作为基础，但是基本类型并不是对象，如果想以对象的方式使用这8中基本类型，可以将它们转换为对应的包装类型。基本类型和包装类型的对应<br><img src="https://img-blog.csdn.net/20180610181924311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>可以直接将整型赋给Integer对象，由编译器来完成从int型到Integer类型的转换，这就叫自动装箱。</li><li>与此对应的，自动拆箱就是可以将包装类型转换为基本类型，具体的转换工作由编译器来完成。</li><li>其他几种基本类型的转换也是类似的</li></ul><h3 id="36、异常和错误"><a href="#36、异常和错误" class="headerlink" title="36、异常和错误"></a>36、异常和错误</h3><ul><li>异常<ul><li>异常即exception</li><li>异常：可以预知、可以通过修改程序来弥补”错误”,可避免的</li></ul></li><li>错误<ul><li>错误：error</li><li>错误：无法预知的，系统级别的，程序员修改程序是无法修复的；例如：系统宕机，JVM挂掉了</li></ul></li><li>Java中的异常<br> <img src="https://img-blog.csdn.net/20180613151854480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><p>异常的种类：</p><ul><li>1、编译时异常(非运行时异常)<ul><li>程序编译过程中产生的， 如果有异常，则不会通过编译，必须手动的捕获异常或者继续抛出该异常；</li></ul></li><li><p>2、运行时异常：</p><ul><li><p>程序在运行过程中产生的，不需要手动抛出或者捕获，系统自动报出；</p><p><a href="https://blog.csdn.net/Song_JiangTao/article/details/82023526#t8" target="_blank" rel="noopener">异常种类及其介绍详情，第9点</a></p></li></ul></li></ul></li><li>异常的处理<ul><li>功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。</li><li>特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。        </li></ul></li><li><p>throws 和throw</p><ul><li>throws 方法声明时使用，表示该方法可能产生的异常，抛出，谁调用谁捕获处理，<strong>throws用在函数上。</strong></li><li><p>throw方法体中使用，表示抛出一个具体的异常对象，谁调用谁捕获处理，<strong>throw用在函数内。</strong></p><p><strong>catch中存在return，此时finally中是否被执行?执行，但是finlly外面程序不会继续执行</strong></p></li></ul></li></ul><h3 id="37、泛型"><a href="#37、泛型" class="headerlink" title="37、泛型"></a>37、泛型</h3><ul><li>了解泛型：泛指一种某一种数据类型；</li><li><a href="https://blog.csdn.net/sunxianghuang/article/details/51982979" target="_blank" rel="noopener">Java泛型深入理解</a>  </li></ul><h3 id="38、集合"><a href="#38、集合" class="headerlink" title="38、集合"></a>38、集合</h3><ul><li>对线性表，链表，哈希表这些常用的数据结构，在进行Java开发时，JDK已经为我们提供了一系列相应的类来实现基本的数据结构。因此，我们一般的程序员不必自己开发相关的方法</li><li>集合（框架）：java提供了一组对数组、链表数据结构操作的API，这组API即集合；存在于java.util<br><img src="https://img-blog.csdn.net/20180620151117512?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li><p>Collection接口有两个子接口：</p><ul><li>Set 接口有两个常用实现类：<ul><li>1、TreeSet<ul><li><strong>基于 TreeMap 的 NavigableSet 实现</strong>。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。<strong>(来自jdk1.6)</strong> <ul><li>自然排序：<pre><code>&gt;自然排序就是按字母书序排序，比如 a-&gt;b-&gt;c.....0-&gt;1-&gt;2-&gt;3....</code></pre>如果是字符串那么会按一个个的字母排序如果相等就比较下一个位置的字符， 知道比出大小位置<br>比如 abc-&gt;acd-&gt;ace-&gt;ade…….</li></ul></li></ul></li><li>2、HashSet(Set最常用的实现类)<ul><li>此类实现 Set 接口，由哈希表（<strong>实际上是一个 HashMap 实例</strong>）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。<strong>(来自jdk1.6)</strong></li></ul></li><li><strong>Set接口特点</strong>：<ul><li>Set 接口<strong>数据不重复</strong>（使用HashMap实例存储的，将存储对象作为key，通过equals方法比较，以及hashcode确认是否相同)</li><li>Set 接口<strong>数据无序</strong>；</li></ul></li><li>常用方法：add(E e)添加元素， iterator()获取迭代器</li></ul></li><li><p>List 接口有三个常用实现类</p><ul><li>1、<strong>ArrayList</strong><ul><li>List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。 <strong>(来自jdk1.6)</strong></li></ul></li><li>2、LinkedList<ul><li>List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。 <strong>(来自jdk1.6)</strong></li></ul></li><li><p>3、Vector</p><ul><li>Vector 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector 的大小可以根据需要增大或缩小，以适应创建 Vector 后进行添加或移除项的操作。 <strong>(来自jdk1.6)</strong></li></ul></li><li><p><strong>List接口的特点</strong>：</p><ul><li><strong>数据有序</strong>，<strong>数据允许重复</strong>的集合</li><li>LinkedList:链表实现，插入，删除元素效率高，查询效率低，线程不安全</li><li>ArrayList:数组实现, 插入，删除元素效率低，查询效率高，线程不安全</li><li>Vector:数组实现，线程安全<ul><li>常用方法：</li></ul></li></ul></li><li>add(对象)添加元素</li><li>get(下标)默认从0开始，获取元素</li><li>remove(int index) remove(Object obj) 根据下标或者元素移除某一个对象</li><li>addAll(Collection cl)将某个集合中元素，合并到当前集合中</li><li>size()该集合长度 contains(Object obj)判断某个元素在该集合中是否存在<ul><li>$\color{red}{将List集合转为数组?}$</li></ul></li><li>list.toArray()<ul><li>$\color{red}{将数组转为List集合?}$</li></ul></li><li>Arrays.asList(objct …a) </li></ul></li></ul></li><li><p>Map接口有两个常用实现类：</p><ul><li>HashMap<ul><li>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<strong>(来自jdk1.6)</strong></li></ul></li><li><p>HashTable</p><ul><li>此类实现一个哈希表，该哈希表将键映射到相应的值。任何非 null 对象都可以用作键或值。 <strong>(来自jdk1.6)</strong></li></ul></li><li><p>map接口的特点</p><ul><li>Map接口不是Cllection的子接口</li><li>Map实现：key value 键值对形式存储数据</li><li>HashTable:键值对不能为空，线程安全，效率低</li><li>HashMap:键值对可以为空，线程不安全，效率高<ul><li>常用方法</li></ul></li><li><code>boolean containsKey(Object key) //测试指定对象是否为此哈希表中的键。</code></li><li><code>put(key,value)//存放数据</code></li><li><code>get(key)//获取元素</code></li><li><p>$\color{red}{map效率最高的遍历方式：}$</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Object&gt; &gt; entrySet=map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; ite=entrySet.iterator();</span><br><span class="line">while(ite.hasNext())&#123;</span><br><span class="line">Map.Entry&lt;String, Object&gt; obj= ite.next();</span><br><span class="line">String key=obj.getKey();</span><br><span class="line">Object value=obj.getValue();</span><br><span class="line">System.out.println(key+&quot;:&quot;+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="39、IO流"><a href="#39、IO流" class="headerlink" title="39、IO流"></a>39、IO流</h3><ul><li>流：<ul><li><strong>流是一组有序的，有起点和终点的字节集合，是对数据传输的总称或抽象。</strong>即数据在两设备间的传输称为流，<strong>流的本质是数据传输</strong>，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</li></ul></li><li>Java中流的分类：<ul><li>按照<strong>数据流向分</strong>：<ul><li>输入流：相对于内存，向内存中写入；</li><li>输出流：相对于内存，从内存往外读；</li></ul></li><li>按照流的<strong>数据传输的格式</strong>：<ul><li>字节流：以字节为单位读取；一般用于读写文件,读写诸如图象或声音等的二进制数据。</li><li>字符流：以字符为单位读取；一般用于读写文件中文本内容</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdn.net/20180620195354649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> </p><h3 id="40、XML解析"><a href="#40、XML解析" class="headerlink" title="40、XML解析"></a>40、XML解析</h3><ul><li><strong>XML是一种可拓展文本标记语言</strong>；</li><li>常用于：数据存储、作为项目配置文件，系统之间<strong>数据传输</strong>的某种数据格式；</li><li>解析方式有：<ul><li>DOM<ul><li>jdk自带的解析方式，事件驱动，不灵活，解析大文件效率低</li></ul></li><li>SAX<ul><li>jdk自带的解析方式，树形结构方式解析操作xml，灵活，大文件效率高</li></ul></li><li>JDOM<ul><li>第三方工具包</li></ul></li><li><strong>DOM4J</strong>：第三方工具包，最常用的一种解析方式<ul><li><a href="https://www.cnblogs.com/sharpest/p/7877501.html" target="_blank" rel="noopener">DOM4J教程补充！</a></li></ul></li></ul></li></ul><h3 id="41、JDBC数据库连接"><a href="#41、JDBC数据库连接" class="headerlink" title="41、JDBC数据库连接"></a>41、JDBC数据库连接</h3><ul><li>java提供的一组操作数据库的API；</li><li>常用接口有：<ul><li><strong>Connection</strong>、</li><li>ResultSet、</li><li><strong>PreparedStatement</strong>、</li><li>Statement    </li></ul></li><li>常用数据库驱动程序和url格式<ul><li>Oracle数据库:<ul><li>驱动程序包名：ojdbc5.jar<ul><li>驱动程序包名有可能会变</li></ul></li><li>驱动类的名字：oracle.jdbc.driver.OracleDriver</li><li>JDBC URL：jdbc:oracle:thin:@$\color{red}{dbip}$:$\color{red}{port}$:$\color{red}{databasename}$<ul><li>JDBC URL中黑色字体部分必须原封不动的保留，为该驱动识别的URL格式。红色字体部分需要根据数据库的安装情况填写。其中各个部分含义如下：<ul><li>dbip 为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1</li><li>port 为数据库的监听端口，需要看安装时的配置，缺省为1521</li><li>databasename 为数据库的SID，通常为全局数据库的名字</li><li>例如：<code>jdbc:oracle:thin:@localhost:1521:XE</code></li></ul></li></ul></li></ul></li><li>Mysql数据库<ul><li>驱动程序包名：mysql-connector-java-5.1.26-bin.jar<ul><li>说明：驱动程序包名有可能会变</li></ul></li><li>驱动类的名字：com.mysql.jdbc.Driver</li><li>JDBC URL：jdbc:mysql://$\color{red}{dbip}$:$\color{red}{port}$/$\color{red}{databasename}$<ul><li>JDBC URL中黑色字体部分必须原封不动的保留，为该驱动识别的URL格式。红色字体部需要根据数据库的安装情况填写。其中各个部分含义如下：<ul><li>dbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1</li><li>port –为数据库的监听端口，需要看安装时的配置，缺省为3306</li><li>databasename –数据库的名字。</li><li>例如：<code>jdbc:mysql://localhost:3306/XE</code></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入Java底层细节🍵</title>
      <link href="/2018/03/04/java%E5%BA%95%E5%B1%82/"/>
      <url>/2018/03/04/java%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>#$\color{blue}{一、究竟何为面向对象？}$</p><ul><li><p>首先，面向对象是一种<strong>思想</strong>，它呢是基于面向过程而言的，$\color{red}{这种思想是对数据的一种优化}$</p><p>  其次，理解<strong>对象</strong>概念，什么是对象？<strong>对象就是类的一个实例</strong>，什么是类？<strong>类就是对一类事物的抽象</strong>，这类事物的共同特性就是程序中的<strong>属性</strong>，共同的行为就是<strong>方法</strong>。</p><p>  例如：动物这个类。有属性name，有方法eat()。动物类的对象：狗，狗呢就具有name的属性和吃的行为。</p><p>  $\color{red}{面向对象的三大特征：封装、继承、多态。}$</p><ul><li>封装：隐藏了对象的具体细节。提高了复用性和安全性</li><li>继承：两个类之间有一些的属性和方法的重复。就使用继承，这样既简化了代码，也提高了代码的复用性</li><li>多态：继承是多态的前提。体现在：<strong>父类对象的引用可以指向子类对象</strong>，这样提高了程序的扩展性</li></ul></li></ul><p>#$\color{blue}{二、jvm}$</p><ul><li><p>大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区），Heap（堆），Program Counter Register（程序计数器） ,   VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的），Native Method Stack  （ 本地方法栈 ），其中Method Area 和  Heap 是线程共享的  ，VM Stack，Native Method Stack  和Program Counter Register  是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 </p><p>  首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ </p><p>  概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） ，  VM Stack（虚拟机栈）和Native Method Stack  （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。 </p><p>  <strong>当我们创建一个对象（new Object）时，就会调用它的构造函数来开辟空间，将对象数据存储到堆内存中，与此同时在栈内存中生成对应的引用，当我们在后续代码中调用的时候用的都是栈内存中的引用，还需注意的一点，基本数据类型是存储在栈内存中。</strong></p><p>  $\color{red}{heap和stack有什么区别?}$<br>java的内存分为两类，一类是栈内存，一类是堆内存。</p></li><li>栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。</li><li><p>堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。</p><p>  更多参考：<br>  <strong>转自：<a href="http://blog.csdn.net/ns_code/article/details/17565503" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17565503</a></strong><br>  <a href="https://blog.csdn.net/ns_code/article/details/17565503" target="_blank" rel="noopener">【深入Java虚拟机】之一：Java内存区域与内存溢出</a><br>  <a href="https://www.cnblogs.com/sunada2005/p/3577799.html" target="_blank" rel="noopener">【转】JVM介绍</a></p></li></ul><p>#$\color{blue}{三、java泛型}$</p><ul><li><strong>加入泛型之前：</strong>如果我们有如下需求：一个StringArr，你只想放string，但你并<strong>不能阻止其他类型数据放入</strong>。为了通用性，这样的数组一般都是Object。当我们获取里面的值的时候，就得<strong>强制转换</strong>，这就是它的缺点。</li><li><strong>加入泛型之后：</strong>例如：<code>ArrayList&lt;String&gt; stringValues=new ArrayList&lt;String&gt;();</code>这样，就指定了具体的类型，添加一些数据的时候，如果不符合初定的类型，就会报错，<strong>安全性提高！</strong>再有就是指定了具体的类型，<strong>提高了代码的质量，可读性提高！</strong></li><li><p><strong>实现原理：</strong><br><img src="https://img-blog.csdn.net/20180824185643558?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如上，两者的类型分明不同，输出的结果却是<strong>true</strong>，这是因为，<strong>泛型它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。</strong>这就是为什么，Java的泛型被称为“伪泛型”的原因</p><p>  <strong>注意点：</strong></p><ul><li>泛型变量不允许是基本数据类型，只能是他们的包装类<br><img src="https://img-blog.csdn.net/20180824190927775?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>静态方法和静态变量不可以使用泛型类所声明的泛型类型参数<br><img src="https://img-blog.csdn.net/20180824191224959?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul><p>#$\color{blue}{四、String类的深入理解}$<br>了解一个类最好的方式就是<strong>看源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** The offset is the first index of the storage that is used. */</span><br><span class="line">    private final int offset;</span><br><span class="line"></span><br><span class="line">    /** The count is the number of characters in the String. */</span><br><span class="line">    private final int count;</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code for the string */</span><br><span class="line">    private int hash; // Default to 0</span><br><span class="line"></span><br><span class="line">    /** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    if (endIndex &gt; count) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    if (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :</span><br><span class="line">        new String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[] = new char[count + otherLen];</span><br><span class="line">    getChars(0, count, buf, 0);</span><br><span class="line">    str.getChars(0, otherLen, buf, count);</span><br><span class="line">    return new String(0, count + otherLen, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String replace(char oldChar, char newChar) &#123;</span><br><span class="line">    if (oldChar != newChar) &#123;</span><br><span class="line">        int len = count;</span><br><span class="line">        int i = -1;</span><br><span class="line">        char[] val = value; /* avoid getfield opcode */</span><br><span class="line">        int off = offset;   /* avoid getfield opcode */</span><br><span class="line"></span><br><span class="line">        while (++i &lt; len) &#123;</span><br><span class="line">        if (val[off + i] == oldChar) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; len) &#123;</span><br><span class="line">        char buf[] = new char[len];</span><br><span class="line">        for (int j = 0 ; j &lt; i ; j++) &#123;</span><br><span class="line">            buf[j] = val[off+j];</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt; len) &#123;</span><br><span class="line">            char c = val[off + i];</span><br><span class="line">            buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(0, len, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多的不再展示。</p><p><strong>从以上的源码中获得信息：</strong></p><ul><li>String是final类，这意味着，这个类不能被继承，也不可有子类，其中的方法默认都是final方法</li><li>String类是通过char数组来保存字符串的</li><li>String类对字符串的操作都是对新字符串操作。$\color{red}{也就是说，String对象一定被创建就不会改变，任何改变操作都不会改变原字符串，而是生成了新的对象}$</li></ul><p><strong>字符串常量池：</strong></p><ul><li>每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。<strong>由于String字符串不可变，所以常量池中一定不存在两个相同的字符串</strong></li><li><p><strong>静态常量池和运行时常量池</strong>。</p><ul><li>静态常量池，即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</li><li><p>运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p><p><img src="https://img-blog.csdn.net/20180824201032316?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>虽说，字符串的比较，我们使用equals方法，但用==号就可以看出，a和b指向的同一个对象。而new以后就产生新的对象。</p><p>如果使用equals比较三者，得出的结果，肯定都是true<br><img src="https://img-blog.csdn.net/20180824202702186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>由于c是new出来的，所以产生了两个对象，一个是栈区中的c，另一个就是堆中的123，他们的引用关系是c-&gt;123-&gt;123(常量池中的)</p><p>也就是说，尽管c是创建在堆中，但其value还是常量池中的123</p><p>当我们对字符串，进行拼接，替换等操作时，会创建一个新的对象来操作，之后旧的对象，就会被当作垃圾回收。</p></li></ul></li></ul><p>#$\color{blue}{五、equals()和==的区别}$<br>他们最大的区别就是一个是方法，一个是关系操作符。</p><p>Object类中的equals方法源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj)</span><br><span class="line">   &#123;</span><br><span class="line">       return this == obj;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可见它直接比较的对象本身。</p><p>String类中的equals方法源码（重写Object中的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的equals比较当中，都运用到了“==”，这就说明，<strong>equals（不管哪个类中的）是==的扩展。</strong></p><p>引用《java编程思想》中的原话：</p><blockquote><p>关系操作符生成的是一个boolean结果，它们计算的是操作数的值之间的关系</p></blockquote><p><strong>总结：</strong></p><ul><li>当==比较基本数据类型的时候，就是比较他们本身的值。</li><li>而==比较引用数据类型的时候， 就是比较他们在内存的地址</li><li>equals用来比较引用数据类型一般都要重写该方法。例如String类就重写了这个方法，</li><li>如果没有重写equals就直接比较，就是比较他们的内存地址</li><li><p>equals不能用于基本数据类型<br><img src="https://img-blog.csdn.net/20180824211327170?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>上面的str中存储的并不是“a”，而是它所指向的对象的地址。所以将他赋值给str2，比较他俩时返回的就是true<br><img src="https://img-blog.csdn.net/20180824211926708?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>上面的Student类并没有重写equals方法，结果位false</p><p> <strong>还有hashCode()方法</strong><br> <img src="https://img-blog.csdn.net/20180824213219881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></li></ul><p>#$\color{blue}{六、int和Integer的区别}$<br> 基本区别：</p><ul><li>（1）Integer是int的包装类；int是基本数据类型； </li><li>（2）Integer变量必须实例化后才能使用；int变量不需要； </li><li>（3）Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； </li><li>（4）Integer的默认值是null；int的默认值是0。</li></ul><p>深入比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer i1 = new Integer(1);</span><br><span class="line">        Integer i2 = new Integer(1);</span><br><span class="line">        Integer i3 = 1;</span><br><span class="line">        Integer i4 = 127;</span><br><span class="line">        Integer i5 = 127;</span><br><span class="line">        Integer i6 = 128;</span><br><span class="line">        Integer i7 = 128;</span><br><span class="line">        int i8 = 1;</span><br><span class="line">        //1、直接比较时，比较两者的地址，每次new生成的都是新的对象</span><br><span class="line">        System.out.println(i1==i2);//false</span><br><span class="line">        //2、integer和int比较时会自动拆箱转换为int类型，然后比较两者的值</span><br><span class="line">        System.out.println(i1==i8);//ture</span><br><span class="line">        //3、非new生成i3指向的是java常量池的对象，new是新生成的</span><br><span class="line">        System.out.println(i1==i3);//false</span><br><span class="line">        //4、127和128问题，JavaAPI中对Integer定义：在-128到127(含)之间的数会缓存，只存在一个对象中，即在此创建只是从缓存中取</span><br><span class="line">            //超过这个每次创建就会new，即产生新的对象</span><br><span class="line">        System.out.println(i4==i5);//true</span><br><span class="line">        System.out.println(i6==i7);//false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/2018082710150514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>以上是测试结果</p><p>#$\color{blue}{七、null和“”的区别}$<br><strong>本质区别：</strong></p><ul><li>null是没有地址的</li><li>“”是有地址的，里边的内容是空的</li></ul><p>具体区别：</p><ul><li>1、做成员变量（字段/属性/类变量）时，如果只写String str；那么是默认赋值为null的。null的话，你屏幕输出（toString方法）的结果为字符串null，而且其它调用str的操作，编译可通过，运行时会空指针异常，此时是异常。</li><li>2、做局部变量（方法里的变量）时，如果只写String str；是不会默认赋值null的，这里仅声明了一个str变量，在栈内存中有定义，但没有任何值，null其实也是一种值。此时任何调用str的操作，编译时就均会报错，是error，不是异常。</li><li><p>3、“”是空字符串，但也是字符串，没有什么东西。 而null是空的意思，什么都没有，没有地址<br><img src="https://img-blog.csdn.net/20180827104250657?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如果你直接输出str1，本质上其实是调用了toString方法。所以就会报错<br>$\color{red}{也就是说，你对没有地址的东西做做操作(除了=)，就会报错}$</p><p>  <strong><code>String str = null;</code>和<code>String str1;</code> 这两者也是不同的，前者是分配了内存，也就是说，你对他可以进行相关操作，而不会报错，后者是不可以的。</strong></p></li></ul><p>#$\color{blue}{八、final、finally和finalize的区别}$<br>$\color{red}{final：}$是<strong>关键字</strong>，是个修饰符。<strong>final不可以和abstract共存</strong></p><ul><li><strong>修饰类：</strong>这样意味着这个类不能有子类，也不能作为父类被继承</li><li><strong>修饰方法：</strong>这样意味着这个方法只能使用，不可以被重写，可以被重载</li><li><strong>修饰变量：</strong>这样意味着这个变量在使用过程中<strong>不可以被改变</strong>，声明时必须赋予初始值，后来用的时候只能读取</li></ul><p>$\color{red}{finally：}$是异常处理时提供finally块来执行一些操作，<strong>不管有没有异常被抛出、捕获，finally块都会被执行</strong></p><ul><li><p>try，catch，finally，<strong>try中的内容如果没有异常时会执行到底，然后去执行finally代码块（如果有的话）；catch代码块中的内容是：try中的内容遇到异常时来执行，try中遇到异常那一行代码之后的代码都不会执行，然后继续执行finally代码块（如果有的话）；finally中的代码是始终都会执行的</strong></p></li><li><p>$\color{red}{try和catch是否必须连用？不是。try能否可以独立存在？不能。}$</p><p>  也就是说：try不可以单独存在，必须和catch和finally的其中一个连用</p></li></ul><p>$\color{red}{finalize：}$是个方法名</p><ul><li><strong>java允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</strong>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，<strong>因此所有的类都继承了它</strong>。子类覆盖finalize()方法以整理系统资源或者被执行其他清理工作。<strong>finalize()方法是在垃圾收集器删除对象之前，对这个对象调用的</strong></li></ul><p>#$\color{blue}{九、异常和错误}$</p><ul><li>异常 <ul><li>异常即exception</li><li>异常：可以预知、可以通过修改程序来弥补”错误”,可避免的</li></ul></li><li>错误 <ul><li>错误：error</li><li>错误：无法预知的，系统级别的，程序员修改程序是无法修复的；例如：系统宕机，JVM挂掉了<br><img src="https://img-blog.csdn.net/20180901104242274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ul><ol><li>粉红色的是编译时异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守.</li><li>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除…</li><li><p>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</p><p> 常见的异常总结：</p><ul><li>1、java.lang.NullPointerException(空指针异常)<br>　 调用了未经初始化的对象或者是不存在的对象</li><li>2、java.lang.ClassNotFoundException<br>　 指定的类不存在</li><li>3、java.lang.NumberFormatException<br>字符串转换为数字异常　　</li><li>4、java.lang.IndexOutOfBoundsException<br>数组下标越界异常</li><li>5、 java.lang.ArithmeticException<br>数学运算异常</li><li>6、 java.lang.ClassCastException<br>数据类型转换异常</li><li>7、java.lang.FileNotFoundException<br>文件未找到异常</li><li>8、java.lang.IllegalArgumentException<br>方法的参数错误</li><li>9、 java.lang.NoSuchMethodException<br>方法不存在异常</li><li><p>10、java.lang.NoClassDefFoundException<br>未找到类定义错误</p><p><strong>违背安全原则异常：SecturityException</strong></p><p><strong>操作数据库异常：SQLException</strong></p><p><strong>输入输出异常：IOException</strong></p><p><strong>通信异常：SocketException</strong></p></li></ul></li></ol><ul><li>异常的处理 <ul><li>功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。<br>特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。</li></ul></li><li><p>throws 和throw</p><ul><li><strong>throws 方法声明时使用</strong>，表示该方法可能产生的异常，抛出，谁调用谁捕获处理，throws用在函数上。</li><li><strong>throw方法体中使用</strong>，表示抛出一个具体的异常对象，谁调用谁捕获处理，throw用在函数内。</li><li>catch中存在return，此时finally中是否被执行?执行。但finally外边不执行。（其实就不能有语句）</li></ul></li></ul><p>#$\color{blue}{十、Java中23种设计模式}$<br><strong>篇幅过长，具体请看大神总结的：</strong><a href="https://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="noopener"><br>Java之美[从菜鸟到高手演变]之设计模式</a><br><a href="https://blog.csdn.net/zhangerqing/article/details/8239539" target="_blank" rel="noopener">Java之美[从菜鸟到高手演变]之设计模式二</a><br><a href="https://blog.csdn.net/zhangerqing/article/details/8243942" target="_blank" rel="noopener">Java之美[从菜鸟到高手演变]之设计模式三</a><br><a href="https://blog.csdn.net/zhangerqing/article/details/8245537" target="_blank" rel="noopener">Java之美[从菜鸟到高手演变]之设计模式四</a><strong>转自：<a href="http://blog.csdn.net/zhangerqing" target="_blank" rel="noopener">http://blog.csdn.net/zhangerqing</a></strong></p><p>#$\color{blue}{十一、java多线程}$</p><ul><li><strong>进程</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</li><li><strong>线程</strong>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li><li><strong>区别并发和并行：</strong>并发是指：多个事件在同一时间间隔内发生，并行是指：多个事件在同一时刻发生</li></ul><p> 更多概念参考<a href="https://blog.csdn.net/Song_JiangTao/article/details/79670805" target="_blank" rel="noopener">操作系统基础知识总结整理</a>的第四大点：处理机管理</p><p> <strong>更多多线程的知识请参考<a href="https://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="noopener">Java中的多线程你只要看这一篇就够了</a></strong></p><p>#$\color{blue}{十二、GC}$</p><ul><li>什么是GC？<ul><li>GC是垃圾收集的意思（Gabage Collection）</li></ul></li><li>为什么要有GC?<ul><li>内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法</li></ul></li><li>垃圾回收器的基本原理是什么?<ul><li><strong>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</strong></li></ul></li><li><p>有什么办法主动通知虚拟机进行垃圾回收？ </p><ul><li><p>程序员可以手动执行<code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>，通知GC运行，但是Java语言规范并不保证GC一定会执行。 我们只是“提醒”一下</p><p><strong>关于Java堆内存结构，分代回收算法，垃圾收集器，GC日志，JVM参数使用</strong>，请参考<a href="https://blog.csdn.net/d6619309/article/details/53358250" target="_blank" rel="noopener">JavaGC介绍</a></p></li></ul></li></ul><p>#$\color{blue}{十三、Java编译一个.java文件生成的.class文件有多少？}$</p><ul><li>一个.java文件中定义多个类，注意一下几点： <ul><li>(1) public权限类只能有一个（<strong>可以一个都没有，但最多只有一个</strong>）；</li><li>(2)这个.java文件名只能是public 权限的类的类名； </li><li>(3)倘若这个文件中没有public 类，则它的.java文件的名字是随便的一个类名； </li><li>(4)当用javac命令生成编译这个.java 文件的时候，则会针对每一个类生成一个.class文件； </li><li>(5)内部类也产生.class文件</li><li>(6)接口也产生.class文件</li></ul></li></ul><p>测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.nuc;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    class a&#123; &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;f&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class c&#123; &#125;</span><br><span class="line">interface a&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>测试结果<br><img src="https://img-blog.csdn.net/20180828111000168?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看出，内部类的.class文件的命名格式为，<strong>外部类名<code>$</code>内部类名.class</strong>，外部类和内部类名使用符号<code>$</code>隔开</p><p><strong>如果有两层内部类</strong>，如下图：<br><img src="https://img-blog.csdn.net/20180828112944148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>#####<em>那么继承父类，实现接口的情况呢？</em></p><p><strong>图一:</strong><br><img src="https://img-blog.csdn.net/20180828111840202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>图二:</strong><br><img src="https://img-blog.csdn.net/20180828112202392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><strong>图一是，接口和父类，Demo类在同一包下测试的结果，编译Demo产生的class文件</strong><br><strong>图二是，不在同一包下的测试结果，Demo类编译时的class文件</strong></p><p>#####<em>那么匿名内部类的情况呢？</em><br>匿名内部类的创建格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 父类构造器(参数列表)|实现接口()</span><br><span class="line">    &#123;  </span><br><span class="line">     //匿名内部类的类体部分  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://img-blog.csdn.net/20180828113743486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可见，匿名内部类，也生成class文件，由于匿名内部类没有名字，所以就按数字来命名，<strong>其规则是按照匿名内部类的顺序递增的。命名格式和内部类相似，名字换成数字即可</strong></p><p>#$\color{blue}{持续更新。。。}$<br>$\color{red}{}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TestGithub</title>
      <link href="/2018/02/02/testGit/"/>
      <url>/2018/02/02/testGit/</url>
      
        <content type="html"><![CDATA[<p>1、第一步:新建文件夹，在当前文件下右键，打开git bash</p><p>2、初始化本地库，之后会多出一个.git文件<br>git init</p><p>3、查看仓库当前的状态<br>git status</p><p>4、查看文件修改了地方<br>git diff</p><p>5、提交到仓库分两步<br>git add<br>git commit</p><p>6、显示从最近到最远的提交日志<br>git log</p><p>7、回退到上一个版本<br>git reset –hard HEAD^</p><p>HEAD本版本，HEAD^是上个版本，HEAD^^上上个版本</p><p>8、这时 git log 发现，最新版本没了，再次显示：<br>it reset –hard  77dd14<br>“77dd514”是你的那个版本的id，写前几位就行，git自动匹配，这个在哪里找呢？一是看记录。</p><p>二：如果你关闭命令行，没有了记录<br>那么使用<br>git reflog        就可看到操作记录，最前面的字符串就是这个id；</p><p>9、git中分为：工作区，暂存区（stage），HEAD区，工作区是你操作的地方，每次的git add都会提交修改到暂存区，commit以后才能放到HEAD区。</p><p>工作区的内容必须先add才能commit</p><p>10、git checkout – fileName可以撤销你工作区的修改操作<br>例如：<br>git checkout – testGit.txt</p><p>11、git reset HEAD <file>可以撤销在存在暂存区的操作，即撤销 git add操作，然后重新放回到工作区<br>例如<br>git reset HEAD testGit.txt</file></p><p>之后在撤销工作区的修改</p><p>12、删除文件，rm fileName,前提是有这个文件<br>rm test.txt</p><p>13、从版本库中删除<br>git rm test.txt<br>git commit -m”delete file”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
