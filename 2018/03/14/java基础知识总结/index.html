<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java," />










<meta name="description" content="1、Java起源 java Sun公司的，后期被甲骨文收购。 Java之父，詹姆斯高斯林， Java语言早起名字叫做：Oak，由C++演变而来； Java 版本：jdk6 /7 最常用， 最新版本10；  2、Java三个平台： JavaSE（标准版，用于桌面应用开发） JavaEE(企业版，用于企业级应用开发) JavaME（微缩版，用于早期嵌入式开发）  3、JavaAPI 即Java应用程序">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识总结🍵">
<meta property="og:url" content="http://yoursite.com/2018/03/14/java基础知识总结/index.html">
<meta property="og:site_name" content="EasyChill&#39;Blogs">
<meta property="og:description" content="1、Java起源 java Sun公司的，后期被甲骨文收购。 Java之父，詹姆斯高斯林， Java语言早起名字叫做：Oak，由C++演变而来； Java 版本：jdk6 /7 最常用， 最新版本10；  2、Java三个平台： JavaSE（标准版，用于桌面应用开发） JavaEE(企业版，用于企业级应用开发) JavaME（微缩版，用于早期嵌入式开发）  3、JavaAPI 即Java应用程序">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdn.net/2018081615364613?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180610165012739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180610181924311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180613151854480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180620151117512?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180620195354649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:updated_time" content="2018-09-21T15:12:26.186Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java基础知识总结🍵">
<meta name="twitter:description" content="1、Java起源 java Sun公司的，后期被甲骨文收购。 Java之父，詹姆斯高斯林， Java语言早起名字叫做：Oak，由C++演变而来； Java 版本：jdk6 /7 最常用， 最新版本10；  2、Java三个平台： JavaSE（标准版，用于桌面应用开发） JavaEE(企业版，用于企业级应用开发) JavaME（微缩版，用于早期嵌入式开发）  3、JavaAPI 即Java应用程序">
<meta name="twitter:image" content="https://img-blog.csdn.net/2018081615364613?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/14/java基础知识总结/"/>





  <title>Java基础知识总结🍵 | EasyChill'Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">EasyChill'Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">专注而非广博</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-联系我">
          <a href="/message/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-envelope"></i> <br />
            
            联系我
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/java基础知识总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="EasyChill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.qqzhi.com/uploadpic/2014-05-04/034226102.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EasyChill'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java基础知识总结🍵</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T13:23:34+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1、Java起源"><a href="#1、Java起源" class="headerlink" title="1、Java起源"></a>1、Java起源</h3><ul>
<li>java Sun公司的，后期被甲骨文收购。</li>
<li>Java之父，詹姆斯高斯林， Java语言早起名字叫做：Oak，由C++演变而来；</li>
<li>Java 版本：jdk6 /7 最常用， 最新版本10；</li>
</ul>
<h3 id="2、Java三个平台："><a href="#2、Java三个平台：" class="headerlink" title="2、Java三个平台："></a>2、Java三个平台：</h3><ul>
<li>JavaSE（标准版，用于桌面应用开发）</li>
<li>JavaEE(企业版，用于企业级应用开发)</li>
<li>JavaME（微缩版，用于早期嵌入式开发）</li>
</ul>
<h3 id="3、JavaAPI"><a href="#3、JavaAPI" class="headerlink" title="3、JavaAPI"></a>3、JavaAPI</h3><ul>
<li>即Java应用程序接口</li>
<li><a href="https://pan.baidu.com/s/13oyAQHH1n8gF0HqXSW5WIg" target="_blank" rel="noopener">Java API 1.6手册下载</a></li>
<li><p>常用API</p>
<ul>
<li><p>StringBuffer和StringBuilder用法</p>
<ul>
<li>StringBuilder(线程不安全)/StringBuffer(线程安全)是可变长度字符串</li>
<li>使用append方法拼接字符串，效率高</li>
<li>默认有16位缓冲区</li>
<li>使用capacity方法获取真实长度，length方法获取字符个数； append方法拼接字符串；</li>
<li>$\color{red}{String 类型和StringBuffer的主要性能区别：}$<ul>
<li>String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。</li>
<li>使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。</li>
<li>在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer。<ul>
<li><strong>性能效率：StringBuilder&gt;StringBuffer&gt;String。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Math相关</p>
<ul>
<li>round(double d) 四舍五入取整返回long/int  </li>
<li>floor(double d) 向下取整返回double</li>
<li>ceil(double d) 向上取整返回double</li>
<li>abs(double/int )获取绝对值</li>
<li>random()获取0-1之间随机小数，非0和1</li>
</ul>
</li>
<li>Random随机数<ul>
<li>nextInt(int i)获取0-i之间的随机整数 </li>
<li>nextDouble()获取0-1之间随机小数，非0和1</li>
</ul>
</li>
<li>java.math.BigDecimal <ul>
<li>比double更精确的一种类型；常用于操作金额，汇率等；</li>
<li>常用方法：<ul>
<li>add</li>
<li>subtract</li>
<li>multiply </li>
<li>divide</li>
<li>setScale </li>
</ul>
</li>
</ul>
</li>
<li>SimpleDateFormat用法<ul>
<li>format(日期对象) 将日期格式化为指定格式字符串</li>
<li>parse(指定格式的日期字符串)将字符串转为Date 注意：格式必须跟SimpleDateFormat指定格式一致否则：<strong>ParseException</strong></li>
</ul>
</li>
<li>java.util.Date<ul>
<li>将1999-10-10格式字符串转为日期对象</li>
<li>new Date()获取当前系统时间</li>
<li>getTime()获取毫秒数</li>
</ul>
</li>
<li>java.sql.Date<ul>
<li>只用于获取系统当前时间</li>
</ul>
</li>
<li>Calendar<ul>
<li><strong>在Calendar类中，月份的值为实际的月份值减1</strong></li>
<li><strong>获得的星期的值和Date类不一样。在Calendar类中，周日是1，周一是2，周二是3，依次类推</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="color-red-总之多查API"><a href="#color-red-总之多查API" class="headerlink" title="#$\color{red}{总之多查API}$"></a>#$\color{red}{总之多查API}$</h3><h3 id="4、Java语言的特性："><a href="#4、Java语言的特性：" class="headerlink" title="4、Java语言的特性："></a>4、Java语言的特性：</h3><ul>
<li>面向对象、</li>
<li>可移植性（一处编译，多处执行）、</li>
<li>跨平台性、</li>
<li>安全性(1、摒弃指针 2、GC垃圾回收机制：<strong>自动释放回收长时间不使用对象的内存</strong>)、<ul>
<li><a href="https://blog.csdn.net/canot/article/details/51037938" target="_blank" rel="noopener">点击深入了解GC</a></li>
</ul>
</li>
<li>并发性(支持多线程)、</li>
</ul>
<h3 id="5、JDK-amp-JRE"><a href="#5、JDK-amp-JRE" class="headerlink" title="5、JDK &amp;JRE"></a>5、JDK &amp;JRE</h3><ul>
<li><p>JDK(Java Development Kit   <strong>Java开发工具包</strong>)，JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。其中的开发工具：编译工具(javac.exe)  打包工具(jar.exe)、执行工具(java.exe)等</p>
</li>
<li><p>JRE(Java Runtime Environment    Java运行环境) ，包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
</li>
</ul>
<h3 id="6、配置环境变量（在任何位置都可以找到java环境）"><a href="#6、配置环境变量（在任何位置都可以找到java环境）" class="headerlink" title="6、配置环境变量（在任何位置都可以找到java环境）"></a>6、配置环境变量（在任何位置都可以找到java环境）</h3><ul>
<li>最简单配置方式：<ul>
<li>系统环境变量：<strong>PATH</strong>：C:\Program Files\Java\jdk1.7.0_13\bin; 后面保留</li>
<li><strong>CLASSPATH</strong>：C:\Program Files\Java\jdk1.7.0_13\lib;.后面保留</li>
</ul>
</li>
<li><p>或者：</p>
<ul>
<li>PATH: %JAVA_HOME%\bin;</li>
<li><p>CLASSPATH:%JAVA_HOME%\lib;.</p>
<p>也可以设置JAVA_HOME<br>JAVA_HOME :C:\Program Files\Java\jdk1.7.0_13</p>
</li>
</ul>
<p>验证是否配置成功： 进入命令行窗口， 执行<strong>java -version</strong>，成功显示版本号即成功配置</p>
</li>
</ul>
<h3 id="7、开发工具："><a href="#7、开发工具：" class="headerlink" title="7、开发工具："></a>7、开发工具：</h3><ul>
<li>Eclipse </li>
<li>MyEclipse </li>
<li>IntelliJ IDEA </li>
</ul>
<h3 id="8、Java程序的执行过程"><a href="#8、Java程序的执行过程" class="headerlink" title="8、Java程序的执行过程"></a>8、Java程序的执行过程</h3><ul>
<li>java源文件，编译器(javac命令)进行编译</li>
<li>生成class文件(存放的字节码)</li>
<li>然后解析器（执行java命令）解析class文件</li>
<li>最后生成计算机识别的二进制编码</li>
</ul>
<h3 id="9、Java有两种数据类型："><a href="#9、Java有两种数据类型：" class="headerlink" title="9、Java有两种数据类型："></a>9、Java有两种数据类型：</h3><ul>
<li>1、<strong>引用数据类型：</strong>数组、类、接口。</li>
<li>2、<strong>基本数据类型：</strong><ul>
<li>整型：byte、short、int、long （8位1个字节、16/2 、32/4、64/8）</li>
<li>浮点型：float、double(32/4 、64/8)</li>
<li>字符型：char(16/2)</li>
<li>布尔类型：boolean</li>
</ul>
</li>
<li><strong>级别从低到高为：</strong> byte,char,short(这三个平级)–&gt;int–&gt;float–&gt;long–&gt;double</li>
<li><strong>自动类型转换：</strong>从低级别到高级别，系统自动转的；</li>
<li><p><strong>强制类型转换：</strong>什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；</p>
<p><strong>Java中默认整数为int类型， 小数为double类型；</strong><br><strong>字符char是否可以存放一个汉字？可以，因为一个字符占2个字节，一个汉字两个字节；</strong><br><strong>整型初始值默认0  浮点型默认0.0 布尔类型默认false 引用数据类型默认null</strong></p>
</li>
</ul>
<h3 id="10、java中是否有goto？-有，是保留字"><a href="#10、java中是否有goto？-有，是保留字" class="headerlink" title="10、java中是否有goto？ 有，是保留字"></a>10、java中是否有goto？ 有，是保留字</h3><h3 id="11、标识符命名规则："><a href="#11、标识符命名规则：" class="headerlink" title="11、标识符命名规则："></a>11、标识符命名规则：</h3><ul>
<li>可以由数字、字母、下划线、$符号组成，但是不能是关键词，不能以数字开头</li>
<li><strong>全局变量(成员变量、类变量)</strong><ul>
<li>可以供当前类的多个方法使用；</li>
<li>定义在类中；</li>
<li>成员变量存在于<strong>堆内存中</strong>，随着对象的产生而存在，消失而消失。</li>
</ul>
</li>
<li><strong>局部变量</strong><ul>
<li>定义在方法中或者方法参数</li>
<li>只能作用于当前方法</li>
<li>没有初始值</li>
<li>局部变量存在于<strong>栈内存中</strong>，随着所属区域的运行而存在，结束而释放。</li>
</ul>
</li>
<li><strong>常量：</strong> 只能声明在类中，使用final关键词声明，必须赋初始值，不能再次赋值；</li>
</ul>
<h3 id="12、Java中数据类型转换："><a href="#12、Java中数据类型转换：" class="headerlink" title="12、Java中数据类型转换："></a>12、Java中数据类型转换：</h3><ul>
<li><strong>隐式转换：</strong>系统默认将其转换为我们需要的数据类型；</li>
<li><p><strong>强制转换：</strong>=号两边数据类型不同时，可以通过,前面加(类型)转换 </p>
<ul>
<li>例如：int j=10;float f=100.123; int j=(int)f;</li>
</ul>
</li>
<li><p><strong>基本数据类型之间规则：</strong></p>
<ul>
<li>(1)整型之间数据类型强制转换规则：long-&gt;int-&gt;short-&gt;byte <ul>
<li>(2)浮点型之间：double-&gt;float <ul>
<li>(3)char和整型 :   整型-&gt;char </li>
</ul>
</li>
</ul>
</li>
<li>(4)char和浮点型:  浮点型-&gt;char</li>
<li>(5)浮点型和整型 :  (double/float)-&gt;(long/int/short/byte) 且小数点舍去</li>
</ul>
</li>
</ul>
<h3 id="13、运算符："><a href="#13、运算符：" class="headerlink" title="13、运算符："></a>13、运算符：</h3><ul>
<li>+</li>
<li>-</li>
<li>*</li>
<li>/ </li>
<li>%<ul>
<li><strong>任何整数模2不是0就是1，</strong>所以只要改变被模数就可以实现开关运算。</li>
</ul>
</li>
<li>位运算符:用于操作二进制位的运算符。<ul>
<li>&amp;  |  ^ &lt;&lt;  &gt;&gt;   &gt;&gt;&gt;(无符号右移)</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>(1)+号拼字符串：”字符串”+数字+数字 和”字符串”+(数字+数字)</li>
<li>(2)分母不可以为0 否则报异常：<strong>ArithmeticException</strong></li>
<li>(3)java中数值运算时，位数多的与位数少的，做运算，最终结果类型为位数多的（long+double 返回double） 整型和浮点型运算，此时返回浮点型</li>
<li>(4)$\color{red}{java中1/2值为多少？0}$</li>
<li>(5)$\color{red}{2的三次幂如何计算？ 2&lt;&lt;2;}$</li>
</ul>
</li>
<li><p>i++ 表示i先参与运算，然后在自身加1 </p>
</li>
<li>++i 表示i先自身加1 然后在被使用</li>
<li><p>类似的 - -运算也是一样的</p>
<p>$\color{red}{注意!}$下面程序是否有错？<br><code>short i=10；
i=i+1;(错误，因为需要强转 short+int结果还是int类型)
i+=1;（正确）</code></p>
</li>
<li><p>逻辑运算符（也叫作短路运算符）：</p>
<ul>
<li>||<ul>
<li>或，两边条件有一个满足true，则结果为true </li>
</ul>
</li>
<li><p>&amp;&amp;</p>
<ul>
<li>与， &amp;&amp;两边条件必须返回boolean类型，两边同时为true则结果为true</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n=10;</span><br><span class="line">int m=100;</span><br><span class="line">boolean f_2=(n&gt;m)&amp;&amp;((n=100000)&lt;100); </span><br><span class="line">System.out.println(n);//n的值还是10</span><br><span class="line">boolean f_3=(m&gt;n)||((n=100000)&lt;100); //n的值还是10</span><br></pre></td></tr></table></figure>
<p><strong>下表为优先级顺序，优先级高的在上部，同一行优先级相同</strong><br><strong>第三行中的“+”“-”为正负的含义</strong><br><img src="https://img-blog.csdn.net/2018081615364613?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
</li>
</ul>
</li>
</ul>
<h3 id="14、判断语句-amp-循环语句break-amp-continue"><a href="#14、判断语句-amp-循环语句break-amp-continue" class="headerlink" title="14、判断语句&amp;循环语句break&amp;continue"></a>14、判断语句&amp;循环语句break&amp;continue</h3><ul>
<li><p>判断语句</p>
<ul>
<li><code>if(条件){}</code></li>
<li>switch选择判断语句<a href="https://blog.csdn.net/qq_38341596/article/details/78629070" target="_blank" rel="noopener">点击查看更多</a></li>
</ul>
</li>
<li><p>循环语句    </p>
<ul>
<li><code>for(;条件;){循环体}</code></li>
<li><code>while(){}</code></li>
<li><code>do{}while()</code></li>
</ul>
</li>
<li>break 表示退出整个循环或者判断</li>
<li>continue 只能用于循环体中，表示退出当前循环，继续下一次循环</li>
</ul>
<h3 id="15、Java的核心包：即java-lang包"><a href="#15、Java的核心包：即java-lang包" class="headerlink" title="15、Java的核心包：即java.lang包"></a>15、Java的核心包：即java.lang包</h3><h3 id="16、包装类：即基本数据类型所对应的类；"><a href="#16、包装类：即基本数据类型所对应的类；" class="headerlink" title="16、包装类：即基本数据类型所对应的类；"></a>16、包装类：即基本数据类型所对应的类；</h3><ul>
<li>int/double/float/byte/long/char/boolean 是一种值表示；</li>
<li><p>Integer/Double/Float/Byte/Long/Character/Boolean 包装类</p>
</li>
<li><p>常用方法：</p>
<ul>
<li>valueOf(“”)</li>
<li>valueOf(int i) </li>
<li>toString（）</li>
<li>parseInt(“”);</li>
<li>$\color{red}{注意异常!}$ NumberFormatException</li>
</ul>
</li>
</ul>
<h3 id="17、-比较和equals比较"><a href="#17、-比较和equals比较" class="headerlink" title="17、==比较和equals比较"></a>17、==比较和equals比较</h3><ul>
<li>==比较即比较内容也比较地址是否相同；</li>
<li><p>equals方法，比较两个对象内容是否相同</p>
<p><strong>注意：</strong></p>
<ul>
<li>（1）字符串比较，不允许用== ，只能通过equals方法</li>
<li><p>（2）如果Integer和Integer/int比较具体是否相等，此时绝对不允许使用== </p>
<ul>
<li><strong>补充：127 128 问题：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 127;</span><br><span class="line">Integer b = 127;</span><br><span class="line">System.out.println(a==b);true</span><br><span class="line">//超一个字节会重新分配空间</span><br><span class="line">Integer c = 128;</span><br><span class="line">Integer d = 128;</span><br><span class="line">System.out.println(c==d);false</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>（3）注意：数字，和字符串比较是否相等；</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;10&quot;;</span><br><span class="line">Integer m=10;</span><br><span class="line">System.out.println(m.equals(str));//false</span><br><span class="line">System.out.println(m.toString().equals(str));//true</span><br></pre></td></tr></table></figure>
<p> <a href="https://blog.csdn.net/Song_JiangTao/article/details/82023526" target="_blank" rel="noopener">更多详情点击查看第5点</a></p>
<h3 id="18、数组："><a href="#18、数组：" class="headerlink" title="18、数组："></a>18、数组：</h3></li>
<li>先定义、开辟空间、赋值在使用</li>
<li>java中数组长度不可变</li>
<li>数组下标从0开始</li>
<li><p><strong>数组的定义：</strong></p>
<ul>
<li>（1） <code>String[] items_0=null;//先定义 items_0=new String[4];//开辟空间</code></li>
<li>（2）<code>String[] items_1=new String[4];</code></li>
<li>（3）<code>String[] items_2={&quot;JONES&quot;,&quot;SMITH&quot;,&quot;XIAOMING&quot;,&quot;SMI&quot;};</code></li>
<li>（4） <code>String[] items_3=new String[]{&quot;SMITH&quot;,&quot;JINES&quot;,&quot;DSFDSF&quot;};</code></li>
</ul>
<p>$\color{red}{如何不通过第三个变量交换两个变量的值？}$ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line">a=a+b;//a:30 b:20</span><br><span class="line">b=a-b;//a:30 b:10</span><br><span class="line">a=a-b;//a:20 b:10</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>二维数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[][] items=new String[2][3];</span><br><span class="line">//items[0]=&#123;&quot;&quot;,&quot;&quot;,&quot;&quot;&#125;;错误的</span><br><span class="line">// items[0]=new String[4];对</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的复制    </p>
<ul>
<li><code>System.arraycopy(strArr,0, strArr1, 0, 3);//从左到右参数意义：从哪个数组，从哪开始复制，复制到哪？开始位置，复制多长</code></li>
<li><code>System.out.println(&quot;copyOf复制：&quot;+Arrays.toString(Arrays.copyOf(strArr, 3)));</code></li>
</ul>
</li>
<li>数组的排序<ul>
<li><code>Arrays.sort(strArr1);</code></li>
</ul>
</li>
</ul>
<h3 id="19、类：是一类事物的描述，程序中为class；"><a href="#19、类：是一类事物的描述，程序中为class；" class="headerlink" title="19、类：是一类事物的描述，程序中为class；"></a>19、类：是一类事物的描述，程序中为class；</h3><ul>
<li>属性：即一类事物具有的共有特点或者特性；程序中为全局变量（成员变量)</li>
<li>方法：一类事物具有的动作； </li>
<li>类的定义和使用<ul>
<li>class 类名称{<br> 属性<br> 方法<br>}</li>
<li>使用关键字new就可以创建类对象，使用<strong>对象.方法，对象.属性</strong>就可完成调用</li>
<li>$\color{red}{创建一个对象都在内存中做了什么事情？}$<ul>
<li>1：先将硬盘上指定位置的Person.class文件加载进内存。</li>
<li>2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。</li>
<li>3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new</li>
<li>4：在该实体空间中进行属性的空间分配，并进行了默认初始化。</li>
<li>5：对空间中的属性进行显示初始化。</li>
<li>6：进行实体的构造代码块初始化。</li>
<li>7：调用该实体对应的构造方法，进行构造方法初始化。（）</li>
<li>8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>抽象类: <strong>abstract</strong><ul>
<li>抽象类的特点：<ul>
<li>1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。</li>
<li>2：抽象方法只定义方法声明，并不定义方法实现。非抽象的方法可以定义方法实现</li>
<li>3：抽象类不可以被创建对象(实例化)。</li>
<li>4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</li>
</ul>
</li>
<li>抽象类的细节：<ul>
<li>1：抽象类中是否有构造方法？有，用于给子类对象进行初始化。</li>
<li>2：抽象类中是否可以定义非抽象方法？可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。<strong>只不过，比一般类多了一个抽象方法。而且比一般类少了一个创建对象的部分。</strong></li>
<li>3：抽象关键字abstract和哪些不可以共存？final ,private , static</li>
<li>4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。</li>
<li>5：抽象类中可以有普通的成员变量</li>
<li>6：抽象类中可以有静态方法</li>
</ul>
</li>
</ul>
</li>
<li>接口：<strong>interface</strong><ul>
<li>接口的特点：<ul>
<li>1、接口<strong>是特殊抽象类</strong>，所有方法都是抽象方法，都是<strong>public访问权限</strong>，数据成员都是<strong>public，static，final</strong></li>
<li>2、<strong>不能被实例化</strong>，方法abstract关键词可以省略，但实际上还是抽象方法</li>
<li>3、<strong>变量都是是常量</strong>，省略final关键词；</li>
<li>4、接口不能被实例化，只能通过<strong>implements</strong>来实现接口，一个实现类，可以实现多个接口</li>
<li>5、接口可以继承接口。</li>
<li>6、实现以后要重写<strong>所有</strong>抽象方法，包括接口继承接口中的抽象方法</li>
<li>7、接口中不能有构造方法</li>
</ul>
</li>
<li>接口的好处：<ul>
<li>1、java由于单继承，接口可以<strong>弥补无法多继承的缺点</strong></li>
<li>2、好的程序要求高内聚低耦合，接口可以实现程序的<strong>解耦</strong></li>
<li>3、定义一种<strong>规范</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>抽象类和接口的区别</strong>：</p>
<ul>
<li>抽象类只能被继承，而且只能单继承。</li>
<li>接口需要被实现，而且可以多实现。<br><br></li>
<li>抽象类中可以定义非抽象方法，子类可以直接继承使用。</li>
<li>接口中都有抽象方法，需要子类去实现。<br><br></li>
<li>抽象类使用的是  is a 关系。</li>
<li>接口使用的 like a 关系。<br><br></li>
<li>抽象类的成员修饰符可以自定义。</li>
<li>接口中的成员修饰符是固定的。全都是public的。<br><br>    </li>
<li>抽象类可以有构造方法，接口中不能有构造方法<br><br>    </li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li>
</ul>
</li>
<li><p>面向对象：<strong>面向对象是一种思想，是基于面向过程而言的</strong>，面向对象即分析某一个事件中有哪些对象，分析他们的动作，具有的属性特点，通过这种方式来解决问题；  </p>
</li>
<li>面向过程： 侧重点在于步骤，通过一步一步调用方法来实现操作</li>
</ul>
<p><a href="https://blog.csdn.net/Song_JiangTao/article/details/82023526" target="_blank" rel="noopener">面向对象的问题详情请点击查看第1点！</a></p>
<ul>
<li>对象实例化： new 类（），即对象的创建；</li>
</ul>
<h3 id="20、static"><a href="#20、static" class="headerlink" title="20、static"></a>20、static</h3><ul>
<li>static 声明方法为静态方法，声明属性为静态属性；</li>
<li>static 关键词：<ul>
<li>1、static 修饰方法，该方法叫做静态方法（也叫做类方法），可直接通过这个类的类名打点直接调用；</li>
<li>2、静态方法中不能使用<strong>this/super</strong>关键词，静态方法不能直接调用当前类中的非静态方法（或非静态属性），必须通过new实例化后在调用。</li>
<li>3、static声明的方法和属性，该对象已经被实例化，且<strong>只能被实例化一次(单例模式)</strong></li>
<li>4、<strong>static修饰的属性，被相同类的不同实例所共享</strong>；</li>
</ul>
</li>
</ul>
<h3 id="21、this"><a href="#21、this" class="headerlink" title="21、this"></a>21、this</h3><ul>
<li>$\color{red}{表示当前类对象，}$<strong>不能用于static声明的方法中，</strong> 常用于区分全局变量和局部变量同名</li>
</ul>
<h3 id="22、super"><a href="#22、super" class="headerlink" title="22、super"></a>22、super</h3><ul>
<li>（1）使用super关键字,$\color{red}{super代表父类对象 }$，<strong>只能用在子类中</strong></li>
<li>（2）可在子类构造方法中调用且<strong>必须是该方法中第一句</strong></li>
<li>（3）不能使用在static修饰的方法中</li>
<li>（4）super的用处<ul>
<li>访问父类构造方法<ul>
<li><code>super();</code></li>
<li><code>super(name);</code></li>
</ul>
</li>
<li>访问父类属性<ul>
<li><code>super.name;</code></li>
</ul>
</li>
<li>访问父类方法<ul>
<li><code>super.print();</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="23、final"><a href="#23、final" class="headerlink" title="23、final"></a>23、final</h3><ul>
<li><p>1.修饰类</p>
<p>  当用final修饰一个类时，<strong>表明这个类不能被继承</strong>。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>  在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。</p>
</li>
<li><p>2.修饰方法</p>
<p>  下面这段话摘自《Java编程思想》第四版第143页：</p>
<blockquote>
<p>使用final方法的原因有两个。<strong>第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。</strong>在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</p>
</blockquote>
</li>
</ul>
<p>　　<strong>因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。</strong></p>
<p>　　$\color{blue}{注：类的private方法会隐式地被指定为final方法。}$</p>
<ul>
<li><p>3.修饰变量     </p>
<p>  对于一个final变量，如果是基本数据类型的变量，则其<strong>数值一旦在初始化之后便不能更改</strong>；如果是引用类型的变量，则在对其<strong>初始化之后便不能再让其指向另一个对象</strong>。</p>
<p>  更多细节访问<a href="https://www.cnblogs.com/dolphin0520/p/3736238.html" target="_blank" rel="noopener">点击这里</a></p>
</li>
</ul>
<h3 id="24、访问修饰符："><a href="#24、访问修饰符：" class="headerlink" title="24、访问修饰符："></a>24、访问修饰符：</h3><p> <img src="https://img-blog.csdn.net/20180610165012739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="25、面向对象三个过程："><a href="#25、面向对象三个过程：" class="headerlink" title="25、面向对象三个过程："></a>25、面向对象三个过程：</h3><ul>
<li>OOA面向对象分析 </li>
<li>OOD面向对象设计</li>
<li>OOP面向对象编程</li>
</ul>
<h3 id="26、面向对象三个特性-属性"><a href="#26、面向对象三个特性-属性" class="headerlink" title="26、面向对象三个特性(属性)"></a>26、面向对象三个特性(属性)</h3><ul>
<li><strong>继承</strong><ul>
<li>继承就是类之间的继承，使用extends来实现，从而实现代码的复用</li>
</ul>
</li>
<li><strong>多态</strong><ul>
<li>某一种事物有不同的具体的体现就是<strong>多态</strong>。</li>
<li>多态<strong>体现</strong>在：重写、重载、对象实例化。</li>
<li>多态的<strong>好处</strong>：提高了程序的扩展性。</li>
<li>多态的<strong>弊端</strong>：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)</li>
</ul>
</li>
<li><strong>封装</strong><ul>
<li><strong>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</strong></li>
<li>好处：将变化隔离；便于使用；提高重用性；安全性。</li>
<li>封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。</li>
</ul>
</li>
</ul>
<h3 id="27、构造方法"><a href="#27、构造方法" class="headerlink" title="27、构造方法"></a>27、构造方法</h3><ul>
<li><strong>该方法与类名相同；没有返回值也不可以使用void 声明</strong></li>
<li>默认public修饰</li>
<li>任何一个类，都有一个无参数的构造方法； 对象实例化时被执行</li>
<li><strong>构造方法和普通方法的区别</strong><ul>
<li>构造方法是在对象创建时，就被调用，构造方法常用于初始化成员变量，而且初始化动作只执行一次。</li>
<li>一般方法，是对象创建后，需要调用才执行，可以被调用多次。</li>
</ul>
</li>
</ul>
<h3 id="28、-程序的执行过程"><a href="#28、-程序的执行过程" class="headerlink" title="28、 程序的执行过程"></a>28、 程序的执行过程</h3><ul>
<li><p>单一类中： </p>
<ul>
<li>1.初始化块2. 静态初始化块3.构造方法</li>
<li><strong>执行顺序：</strong>静态初始化块（永远只被执行一次） 初始化块 构造方法</li>
</ul>
</li>
<li><p>父类和子类中都有静态代码块，非静态代码块，构造方法时。</p>
<ul>
<li>初始化子类对象时，<strong>调用顺序：</strong>父类静态，子类静态，父类非静态，父类构造，子类非静态，子类构造</li>
</ul>
</li>
<li><p><strong>静态域</strong></p>
<ul>
<li>其实最先初始化的并不是静态块，而是静态域，而静态域中包含静态变量、静态块和静态方法，其中需要初始化的是静态变量和静态块。而他们两个的初始化顺序是靠他们俩的位置决定的!</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class B</span><br><span class="line">&#123;</span><br><span class="line">    public static B t1 = new B();</span><br><span class="line">    public static B t2 = new B();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;构造块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;静态块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        B t = new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：构造块 构造块 静态块 构造块</strong></p>
</li>
</ul>
<h3 id="29、方法重载：overload"><a href="#29、方法重载：overload" class="headerlink" title="29、方法重载：overload"></a>29、方法重载：overload</h3><ul>
<li><strong>当前类中方法名相同，参数个数或者参数类型不同；</strong> </li>
<li><p>public String student(String name,int age){…….}<br>public void student(int age,String name){………}<br>这个也是重载</p>
</li>
<li><p>为什么重载，重载有什么好处？</p>
<ul>
<li>了解：好处便于记忆筛选，体现了java的多态</li>
</ul>
</li>
</ul>
<h3 id="30、方法重写：override"><a href="#30、方法重写：override" class="headerlink" title="30、方法重写：override"></a>30、方法重写：override</h3><ul>
<li><strong>发生在子类中，子类的方法与父类方法名、参数个数、参数类型，返回值类型完全相同，并且访问权限不能严于父类</strong></li>
<li>什么时候使用重写？<ul>
<li>1、当父类方法无法满足子类需求，此时可以在子类中重写父类方法</li>
<li>2、如果开发时，需要对父类方法功能拓展，此时还不想修改父类程序<br>则使用继承(定义一个类继承父类)，然后通过子类重写该方法，<br>然后其他类进行调用这个子类方法； </li>
</ul>
</li>
</ul>
<h3 id="31、继承："><a href="#31、继承：" class="headerlink" title="31、继承："></a>31、继承：</h3><ul>
<li>子类继承父类，可以继承父类中<strong>非私有的方法和属性</strong>；</li>
<li>构造方法无法被继承；</li>
<li>final修饰的类无法被继承；</li>
<li>Java中是单继承，<strong>所有类的超类（父类/基类）是java.lang.Object类</strong></li>
<li>$\color{red}{如果一个类既继承了一个类又实现了接口，那么次序是，先继承，后实现！！}$</li>
<li><p>子类被实例化时，先实例化父类对象</p>
<ul>
<li><p>java中是单继承，即一个类只能有一个父类；所有类的父类（超类）是java.lang.Object</p>
<ul>
<li><p>继承的好处：</p>
<ul>
<li>1、简化子类代码</li>
<li>2、使用继承可以不修改父类程序前提，完成对父类方法的拓展</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
<li>1、打破了封装（封装的目的是隐藏），父类向子类暴露了细节</li>
<li>2、过多的继承，会导致程序不便于维护</li>
<li>3、白盒重用，因为基类的内部细节通常对子类是可见的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="32、所有类的父类Object类"><a href="#32、所有类的父类Object类" class="headerlink" title="32、所有类的父类Object类"></a>32、所有类的父类Object类</h3><ul>
<li>Object位于java.lang包下面</li>
<li>其中常用的方法有：<ul>
<li><strong>toString();</strong> 返回当前对象本身的有关信息，按字符串对象返回</li>
<li><strong>equals();</strong> 比较两个对象是否是同一个对象，是则返回true</li>
<li>hashCode(); 返回该对象的哈希代码值</li>
<li>getClass(); 获取当前对象所属的类信息，返回Class对象</li>
</ul>
</li>
<li>equals方法的重写：<ul>
<li>什么时候重写equals方法？<ul>
<li>比较两个对象时候，需要重写equals方法，重新定义比较规则</li>
</ul>
</li>
</ul>
</li>
<li>toString方法重写：<ul>
<li>重写toString方法的目的是：让对象以某个字符串形式表示</li>
</ul>
</li>
</ul>
<h3 id="33、主方法的分析"><a href="#33、主方法的分析" class="headerlink" title="33、主方法的分析"></a>33、主方法的分析</h3><ul>
<li><code>public static void main(String[] args){}</code></li>
<li><p>1）保证该类的独立运行。</p>
</li>
<li><p>2）它是程序的入口。</p>
</li>
<li><p>3）它被jvm调用。</p>
<ul>
<li><p>Public：访问权限最大。</p>
</li>
<li><p>static：不需要对象，直接类名即可。</p>
</li>
<li><p>void：主方法没有返回值。</p>
</li>
<li><p>main：主方法特定的名称。</p>
</li>
<li><p>(String[] args)：主方法的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。</p>
<p><strong>注意：主方法的存在，仅为该类是否需要独立运行，如果不需要，主方法是不用定义的。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="34、Java内存的总结"><a href="#34、Java内存的总结" class="headerlink" title="34、Java内存的总结"></a>34、Java内存的总结</h3><ul>
<li><p>java分了5片内存</p>
<ul>
<li>1：寄存器。</li>
<li>2：本地方法区。</li>
<li>3：方法区。</li>
<li>4：栈。</li>
<li>5：堆。</li>
</ul>
</li>
<li><p>栈：存储的都是局部变量 ( 方法中定义的变量，方法上的参数，语句中的变量 )；<strong>只要数据运算完成所在的区域结束，该数据就会被释放。</strong></p>
</li>
<li><p>堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。</p>
<pre><code>- 1：每一个实体都有内存首地址值
- 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。
- 3：垃圾回收机制。    
</code></pre><h3 id="35、自动装箱，自动拆箱"><a href="#35、自动装箱，自动拆箱" class="headerlink" title="35、自动装箱，自动拆箱"></a>35、自动装箱，自动拆箱</h3></li>
<li>Java有8种基本类型，每种基本类型又有对应的包装类型。在Java中，一切都以对象作为基础，但是基本类型并不是对象，如果想以对象的方式使用这8中基本类型，可以将它们转换为对应的包装类型。基本类型和包装类型的对应<br><img src="https://img-blog.csdn.net/20180610181924311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li>
<li>可以直接将整型赋给Integer对象，由编译器来完成从int型到Integer类型的转换，这就叫自动装箱。</li>
<li>与此对应的，自动拆箱就是可以将包装类型转换为基本类型，具体的转换工作由编译器来完成。</li>
<li>其他几种基本类型的转换也是类似的</li>
</ul>
<h3 id="36、异常和错误"><a href="#36、异常和错误" class="headerlink" title="36、异常和错误"></a>36、异常和错误</h3><ul>
<li>异常<ul>
<li>异常即exception</li>
<li>异常：可以预知、可以通过修改程序来弥补”错误”,可避免的</li>
</ul>
</li>
<li>错误<ul>
<li>错误：error</li>
<li>错误：无法预知的，系统级别的，程序员修改程序是无法修复的；例如：系统宕机，JVM挂掉了</li>
</ul>
</li>
<li>Java中的异常<br> <img src="https://img-blog.csdn.net/20180613151854480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li>
<li><p>异常的种类：</p>
<ul>
<li>1、编译时异常(非运行时异常)<ul>
<li>程序编译过程中产生的， 如果有异常，则不会通过编译，必须手动的捕获异常或者继续抛出该异常；</li>
</ul>
</li>
<li><p>2、运行时异常：</p>
<ul>
<li><p>程序在运行过程中产生的，不需要手动抛出或者捕获，系统自动报出；</p>
<p><a href="https://blog.csdn.net/Song_JiangTao/article/details/82023526#t8" target="_blank" rel="noopener">异常种类及其介绍详情，第9点</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>异常的处理<ul>
<li>功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。</li>
<li>特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。        </li>
</ul>
</li>
<li><p>throws 和throw</p>
<ul>
<li>throws 方法声明时使用，表示该方法可能产生的异常，抛出，谁调用谁捕获处理，<strong>throws用在函数上。</strong></li>
<li><p>throw方法体中使用，表示抛出一个具体的异常对象，谁调用谁捕获处理，<strong>throw用在函数内。</strong></p>
<p><strong>catch中存在return，此时finally中是否被执行?执行，但是finlly外面程序不会继续执行</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="37、泛型"><a href="#37、泛型" class="headerlink" title="37、泛型"></a>37、泛型</h3><ul>
<li>了解泛型：泛指一种某一种数据类型；</li>
<li><a href="https://blog.csdn.net/sunxianghuang/article/details/51982979" target="_blank" rel="noopener">Java泛型深入理解</a>  </li>
</ul>
<h3 id="38、集合"><a href="#38、集合" class="headerlink" title="38、集合"></a>38、集合</h3><ul>
<li>对线性表，链表，哈希表这些常用的数据结构，在进行Java开发时，JDK已经为我们提供了一系列相应的类来实现基本的数据结构。因此，我们一般的程序员不必自己开发相关的方法</li>
<li>集合（框架）：java提供了一组对数组、链表数据结构操作的API，这组API即集合；存在于java.util<br><img src="https://img-blog.csdn.net/20180620151117512?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li>
<li><p>Collection接口有两个子接口：</p>
<ul>
<li>Set 接口有两个常用实现类：<ul>
<li>1、TreeSet<ul>
<li><strong>基于 TreeMap 的 NavigableSet 实现</strong>。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。<strong>(来自jdk1.6)</strong> <ul>
<li>自然排序：<pre><code>&gt;自然排序就是按字母书序排序，
比如 a-&gt;b-&gt;c.....
0-&gt;1-&gt;2-&gt;3....
</code></pre>如果是字符串那么会按一个个的字母排序如果相等就比较下一个位置的字符， 知道比出大小位置<br>比如 abc-&gt;acd-&gt;ace-&gt;ade…….</li>
</ul>
</li>
</ul>
</li>
<li>2、HashSet(Set最常用的实现类)<ul>
<li>此类实现 Set 接口，由哈希表（<strong>实际上是一个 HashMap 实例</strong>）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。<strong>(来自jdk1.6)</strong></li>
</ul>
</li>
<li><strong>Set接口特点</strong>：<ul>
<li>Set 接口<strong>数据不重复</strong>（使用HashMap实例存储的，将存储对象作为key，通过equals方法比较，以及hashcode确认是否相同)</li>
<li>Set 接口<strong>数据无序</strong>；</li>
</ul>
</li>
<li>常用方法：add(E e)添加元素， iterator()获取迭代器</li>
</ul>
</li>
<li><p>List 接口有三个常用实现类</p>
<ul>
<li>1、<strong>ArrayList</strong><ul>
<li>List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。 <strong>(来自jdk1.6)</strong></li>
</ul>
</li>
<li>2、LinkedList<ul>
<li>List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。 <strong>(来自jdk1.6)</strong></li>
</ul>
</li>
<li><p>3、Vector</p>
<ul>
<li>Vector 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector 的大小可以根据需要增大或缩小，以适应创建 Vector 后进行添加或移除项的操作。 <strong>(来自jdk1.6)</strong></li>
</ul>
</li>
<li><p><strong>List接口的特点</strong>：</p>
<ul>
<li><strong>数据有序</strong>，<strong>数据允许重复</strong>的集合</li>
<li>LinkedList:链表实现，插入，删除元素效率高，查询效率低，线程不安全</li>
<li>ArrayList:数组实现, 插入，删除元素效率低，查询效率高，线程不安全</li>
<li>Vector:数组实现，线程安全<ul>
<li>常用方法：</li>
</ul>
</li>
</ul>
</li>
<li>add(对象)添加元素</li>
<li>get(下标)默认从0开始，获取元素</li>
<li>remove(int index) remove(Object obj) 根据下标或者元素移除某一个对象</li>
<li>addAll(Collection cl)将某个集合中元素，合并到当前集合中</li>
<li>size()该集合长度 contains(Object obj)判断某个元素在该集合中是否存在<ul>
<li>$\color{red}{将List集合转为数组?}$</li>
</ul>
</li>
<li>list.toArray()<ul>
<li>$\color{red}{将数组转为List集合?}$</li>
</ul>
</li>
<li>Arrays.asList(objct …a) </li>
</ul>
</li>
</ul>
</li>
<li><p>Map接口有两个常用实现类：</p>
<ul>
<li>HashMap<ul>
<li>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<strong>(来自jdk1.6)</strong></li>
</ul>
</li>
<li><p>HashTable</p>
<ul>
<li>此类实现一个哈希表，该哈希表将键映射到相应的值。任何非 null 对象都可以用作键或值。 <strong>(来自jdk1.6)</strong></li>
</ul>
</li>
<li><p>map接口的特点</p>
<ul>
<li>Map接口不是Cllection的子接口</li>
<li>Map实现：key value 键值对形式存储数据</li>
<li>HashTable:键值对不能为空，线程安全，效率低</li>
<li>HashMap:键值对可以为空，线程不安全，效率高<ul>
<li>常用方法</li>
</ul>
</li>
<li><code>boolean containsKey(Object key) //测试指定对象是否为此哈希表中的键。</code></li>
<li><code>put(key,value)//存放数据</code></li>
<li><code>get(key)//获取元素</code></li>
<li><p>$\color{red}{map效率最高的遍历方式：}$</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Object&gt; &gt; entrySet=map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; ite=entrySet.iterator();</span><br><span class="line">while(ite.hasNext())&#123;</span><br><span class="line">	Map.Entry&lt;String, Object&gt; obj= ite.next();</span><br><span class="line">	String key=obj.getKey();</span><br><span class="line">	Object value=obj.getValue();</span><br><span class="line">	System.out.println(key+&quot;:&quot;+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="39、IO流"><a href="#39、IO流" class="headerlink" title="39、IO流"></a>39、IO流</h3><ul>
<li>流：<ul>
<li><strong>流是一组有序的，有起点和终点的字节集合，是对数据传输的总称或抽象。</strong>即数据在两设备间的传输称为流，<strong>流的本质是数据传输</strong>，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</li>
</ul>
</li>
<li>Java中流的分类：<ul>
<li>按照<strong>数据流向分</strong>：<ul>
<li>输入流：相对于内存，向内存中写入；</li>
<li>输出流：相对于内存，从内存往外读；</li>
</ul>
</li>
<li>按照流的<strong>数据传输的格式</strong>：<ul>
<li>字节流：以字节为单位读取；一般用于读写文件,读写诸如图象或声音等的二进制数据。</li>
<li>字符流：以字符为单位读取；一般用于读写文件中文本内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180620195354649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> </p>
<h3 id="40、XML解析"><a href="#40、XML解析" class="headerlink" title="40、XML解析"></a>40、XML解析</h3><ul>
<li><strong>XML是一种可拓展文本标记语言</strong>；</li>
<li>常用于：数据存储、作为项目配置文件，系统之间<strong>数据传输</strong>的某种数据格式；</li>
<li>解析方式有：<ul>
<li>DOM<ul>
<li>jdk自带的解析方式，事件驱动，不灵活，解析大文件效率低</li>
</ul>
</li>
<li>SAX<ul>
<li>jdk自带的解析方式，树形结构方式解析操作xml，灵活，大文件效率高</li>
</ul>
</li>
<li>JDOM<ul>
<li>第三方工具包</li>
</ul>
</li>
<li><strong>DOM4J</strong>：第三方工具包，最常用的一种解析方式<ul>
<li><a href="https://www.cnblogs.com/sharpest/p/7877501.html" target="_blank" rel="noopener">DOM4J教程补充！</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="41、JDBC数据库连接"><a href="#41、JDBC数据库连接" class="headerlink" title="41、JDBC数据库连接"></a>41、JDBC数据库连接</h3><ul>
<li>java提供的一组操作数据库的API；</li>
<li>常用接口有：<ul>
<li><strong>Connection</strong>、</li>
<li>ResultSet、</li>
<li><strong>PreparedStatement</strong>、</li>
<li>Statement    </li>
</ul>
</li>
<li>常用数据库驱动程序和url格式<ul>
<li>Oracle数据库:<ul>
<li>驱动程序包名：ojdbc5.jar<ul>
<li>驱动程序包名有可能会变</li>
</ul>
</li>
<li>驱动类的名字：oracle.jdbc.driver.OracleDriver</li>
<li>JDBC URL：jdbc:oracle:thin:@$\color{red}{dbip}$:$\color{red}{port}$:$\color{red}{databasename}$<ul>
<li>JDBC URL中黑色字体部分必须原封不动的保留，为该驱动识别的URL格式。红色字体部分需要根据数据库的安装情况填写。其中各个部分含义如下：<ul>
<li>dbip 为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1</li>
<li>port 为数据库的监听端口，需要看安装时的配置，缺省为1521</li>
<li>databasename 为数据库的SID，通常为全局数据库的名字</li>
<li>例如：<code>jdbc:oracle:thin:@localhost:1521:XE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Mysql数据库<ul>
<li>驱动程序包名：mysql-connector-java-5.1.26-bin.jar<ul>
<li>说明：驱动程序包名有可能会变</li>
</ul>
</li>
<li>驱动类的名字：com.mysql.jdbc.Driver</li>
<li>JDBC URL：jdbc:mysql://$\color{red}{dbip}$:$\color{red}{port}$/$\color{red}{databasename}$<ul>
<li>JDBC URL中黑色字体部分必须原封不动的保留，为该驱动识别的URL格式。红色字体部需要根据数据库的安装情况填写。其中各个部分含义如下：<ul>
<li>dbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1</li>
<li>port –为数据库的监听端口，需要看安装时的配置，缺省为3306</li>
<li>databasename –数据库的名字。</li>
<li>例如：<code>jdbc:mysql://localhost:3306/XE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/04/java底层/" rel="next" title="深入Java底层细节🍵">
                <i class="fa fa-chevron-left"></i> 深入Java底层细节🍵
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/02/【Spring注入】属性，对象，集合，数组/" rel="prev" title="Spring注入之属性、对象、集合、数组四种方式🍂">
                Spring注入之属性、对象、集合、数组四种方式🍂 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://www.qqzhi.com/uploadpic/2014-05-04/034226102.jpg"
                alt="EasyChill" />
            
              <p class="site-author-name" itemprop="name">EasyChill</p>
              <p class="site-description motion-element" itemprop="description">这里是我的博客以及生活总结</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/24bc1eb70081" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-book"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/mrsongjiangtao" target="_blank" title="Github">
                      
                        <i class="fa fa-fw fa-github"></i>Github</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://img-blog.csdn.net/20180922081342916?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdfSmlhbmdUYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=378985282" target="_blank" title="网易云">
                      
                        <i class="fa fa-fw fa-music"></i>网易云</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Java起源"><span class="nav-number">1.</span> <span class="nav-text">1、Java起源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、Java三个平台："><span class="nav-number">2.</span> <span class="nav-text">2、Java三个平台：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、JavaAPI"><span class="nav-number">3.</span> <span class="nav-text">3、JavaAPI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#color-red-总之多查API"><span class="nav-number">4.</span> <span class="nav-text">#$\color{red}{总之多查API}$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、Java语言的特性："><span class="nav-number">5.</span> <span class="nav-text">4、Java语言的特性：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、JDK-amp-JRE"><span class="nav-number">6.</span> <span class="nav-text">5、JDK &amp;JRE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、配置环境变量（在任何位置都可以找到java环境）"><span class="nav-number">7.</span> <span class="nav-text">6、配置环境变量（在任何位置都可以找到java环境）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、开发工具："><span class="nav-number">8.</span> <span class="nav-text">7、开发工具：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、Java程序的执行过程"><span class="nav-number">9.</span> <span class="nav-text">8、Java程序的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、Java有两种数据类型："><span class="nav-number">10.</span> <span class="nav-text">9、Java有两种数据类型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、java中是否有goto？-有，是保留字"><span class="nav-number">11.</span> <span class="nav-text">10、java中是否有goto？ 有，是保留字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、标识符命名规则："><span class="nav-number">12.</span> <span class="nav-text">11、标识符命名规则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、Java中数据类型转换："><span class="nav-number">13.</span> <span class="nav-text">12、Java中数据类型转换：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、运算符："><span class="nav-number">14.</span> <span class="nav-text">13、运算符：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、判断语句-amp-循环语句break-amp-continue"><span class="nav-number">15.</span> <span class="nav-text">14、判断语句&amp;循环语句break&amp;continue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15、Java的核心包：即java-lang包"><span class="nav-number">16.</span> <span class="nav-text">15、Java的核心包：即java.lang包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16、包装类：即基本数据类型所对应的类；"><span class="nav-number">17.</span> <span class="nav-text">16、包装类：即基本数据类型所对应的类；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、-比较和equals比较"><span class="nav-number">18.</span> <span class="nav-text">17、==比较和equals比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18、数组："><span class="nav-number">19.</span> <span class="nav-text">18、数组：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19、类：是一类事物的描述，程序中为class；"><span class="nav-number">20.</span> <span class="nav-text">19、类：是一类事物的描述，程序中为class；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20、static"><span class="nav-number">21.</span> <span class="nav-text">20、static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21、this"><span class="nav-number">22.</span> <span class="nav-text">21、this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22、super"><span class="nav-number">23.</span> <span class="nav-text">22、super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23、final"><span class="nav-number">24.</span> <span class="nav-text">23、final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24、访问修饰符："><span class="nav-number">25.</span> <span class="nav-text">24、访问修饰符：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25、面向对象三个过程："><span class="nav-number">26.</span> <span class="nav-text">25、面向对象三个过程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26、面向对象三个特性-属性"><span class="nav-number">27.</span> <span class="nav-text">26、面向对象三个特性(属性)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27、构造方法"><span class="nav-number">28.</span> <span class="nav-text">27、构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28、-程序的执行过程"><span class="nav-number">29.</span> <span class="nav-text">28、 程序的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29、方法重载：overload"><span class="nav-number">30.</span> <span class="nav-text">29、方法重载：overload</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30、方法重写：override"><span class="nav-number">31.</span> <span class="nav-text">30、方法重写：override</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31、继承："><span class="nav-number">32.</span> <span class="nav-text">31、继承：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32、所有类的父类Object类"><span class="nav-number">33.</span> <span class="nav-text">32、所有类的父类Object类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33、主方法的分析"><span class="nav-number">34.</span> <span class="nav-text">33、主方法的分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34、Java内存的总结"><span class="nav-number">35.</span> <span class="nav-text">34、Java内存的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35、自动装箱，自动拆箱"><span class="nav-number">36.</span> <span class="nav-text">35、自动装箱，自动拆箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36、异常和错误"><span class="nav-number">37.</span> <span class="nav-text">36、异常和错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37、泛型"><span class="nav-number">38.</span> <span class="nav-text">37、泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38、集合"><span class="nav-number">39.</span> <span class="nav-text">38、集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39、IO流"><span class="nav-number">40.</span> <span class="nav-text">39、IO流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40、XML解析"><span class="nav-number">41.</span> <span class="nav-text">40、XML解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41、JDBC数据库连接"><span class="nav-number">42.</span> <span class="nav-text">41、JDBC数据库连接</span></a></li></ol></div>
            
            <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=447076485&auto=1&height=66"></iframe>
          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EasyChill</span>

  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
